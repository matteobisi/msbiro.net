[{"content":"Hello, I’m Matteo Bisi.\nI’m a DevSecOps Team Leader currently living in Galway, Ireland, but originally from Italy.\nWith a passion for both technology and teamwork, I lead my team in building and securing cloud-native infrastructures using both open source and enterprise tools.\nMy journey has taken me across different roles, giving me a unique perspective on how diverse teams collaborate and innovate.\nI’m particularly interested in automating security practices, managing secrets at scale, and empowering development teams to deliver secure software efficiently.\nOutside of work, I enjoy exploring the beautiful Irish countryside, planning my next family trip, and cooking some Italian recipes.\nThrough this blog, I hope to share insights, best practices, and lessons learned from my experiences leading DevSecOps teams.\nYou can find more information about my CV on my LinkedIn profile.\nMy preavious blogs about Collaboration solutions are available here:\nitalian blog english blog ","permalink":"http://localhost:1313/aboutme/","tags":["biography"],"title":"About Me - Matteo Bisi"},{"content":"As I wrote in my last post, CyberArk Conjur is an enterprise secrets manager. , CyberArk Conjur is an enterprise secrets manager.\nIn this post, I’ll provide an architecture overview along with the main system requirements.\nConjur is currently available in two versions: Enterprise and open source (known as OSS).\nA “cloud” version will be available soon, offered as a SaaS solution.\nThis post focuses on the Enterprise version, which is similar but not identical to the OSS version.\nArchitecture Conjur is distributed as a Docker image, making deployment and configuration fast and secure.\nThe main services included in the appliance image are:\nnginx: Provides access to the administrative GUI and the API set for interacting with secrets. PostgreSQL database: Two databases, one for configurations and secrets, and one for audit logs. Conjur appliance: The core product. syslog-ng: Used to collect audit and access logs. The smallest common configuration for Conjur Enterprise is a three-node cluster with auto-failover, as shown in the following diagram:\nThe cluster architecture follows an active-passive model, with high availability guaranteed by a load balancer placed in front of the cluster. This load balancer switches the node accessed by applications in case of a failure.\nWithin the cluster, one node acts as the “leader node,” handling all read/write operations and providing the API for applications to interact with secrets.\nThe secondary nodes are called “standbys” and can be either synchronous or asynchronous, depending on the PostgreSQL replication setup.\nThese nodes are inactive and do not provide API services.\nIf the leader node fails, after a configurable period, the standbys will elect a new leader using etcd and the Raft consensus algorithm.\nIf auto-failover is not configured, manual promotion is required.\nIt is also possible to configure a primary site with auto-failover and a secondary site with asynchronous standbys (without auto-failover), ready to be promoted manually.\nThe final component of the architecture is the “follower,” a read-only replica of the leader. Followers allow secrets to be read at scale and are horizontally scalable components typically configured behind a load balancer to handle all types of read requests, including authentication, permission checks, and secret fetches.\nFollowers are usually installed on a Kubernetes cluster to serve applications with low latency.\nThe architecture diagram with followers could be expanded as shown below:\nSystem Requirements Production environment:\n4 cores 8 GB RAM 50 GB hard drive Test environment:\n2 cores 4 GB RAM 20 GB hard drive Supported container runtimes:\nDocker 1.13 or later Mirantis Container Runtime (MRC) 19.x, 20.10 on RHEL 8.x Kubernetes and OpenShift (only for the follower) Podman 3.3 and 3.4 The host server should run an operating system supported by the container runtime (the most popular are RHEL Server, RHEL-based, or Ubuntu Server LTS). To read more detail or updated versions please refer to this page.\nIf the customer environment also includes a CyberArk Vault server that needs to be synchronized with Conjur, the following are the requirements for a CyberArk Vault Synchronizer server:\n4 cores 8 GB RAM Windows Server 2012 R2 or later ","permalink":"http://localhost:1313/posts/cyberark-conjur-architecture-system-requirements/","tags":["conjur","cyberark","secrets manager"],"title":"CyberArk Conjur: A Quick Overview of Architecture and System Requirements"},{"content":"Security is always a complex topic to address, as an error or omission in processes can lead to serious economic or reputational damage for a company.\nWhen we talk about “secrets,” consider the following examples:\nUsernames Database passwords SSL certificates and keys SSH keys Cloud credentials Simply reading through this list helps to explain why this topic needs to be considered and handled carefully.\nSome common bad practices or risks include:\nHardcoding secrets in code Data breaches Password leaks Secrets pushed to public repositories With practices like lateral movement, just one compromised secret can be enough to compromise an entire environment. To help prevent these risks, there are tools known as “enterprise secrets managers.” I’d like to start a series of posts on this blog about CyberArk Conjur.\nConjur allows you to avoid direct use of secrets by leveraging a set of REST APIs, making it a programmable tool that can be accessed via URL or open source utilities.\nSecurity is enforced through security policies without slowing down the developers involved.\nCorporate security can be further improved with the use of rotators, which programmatically change secret values.\nIf other CyberArk software like PAS Vault is already in use, Conjur can be integrated using the Synchroniser component,\nproviding the same level of security for cloud-native infrastructure.\nConjur is available in two versions: enterprise and open source, each with distinct features.\nIn upcoming posts, I will explain details about the architecture, secrets management, and product news related to CyberArk Conjur.\n","permalink":"http://localhost:1313/posts/why-you-need-kubernetes-secrets-manager/","tags":["conjur","introduction","secrets manager"],"title":"CyberArk Conjur - why you (probably) need an enterprise secrets manager"},{"content":"Hello there! How are you?\nI’m really good! As you may have seen on my social media, starting from the 16th of May, I’ve begun a new position as Senior DevSecOps at SIGHUP.\nI’m really excited about this new opportunity, and I’m writing this post because it will also have an effect on this blog’s focus.\nThe topics will shift from previous subjects to cloud-native infrastructure security, starting with tools like CyberArk Conjur. The previous content on this blog will remain here forever. I believe it could be helpful for some time, and I also want to honor my HCL Ambassador role.\nI’d also love to add that my current role as organizer of the LetsConnect user group will remain unchanged.\nI hope to see you all again at our next event!\n","permalink":"http://localhost:1313/posts/new-job-devsecops-teamleader/","tags":["cloudnative","newjob","devsecops","security"],"title":"I've started a new journey as DevSecOps Team Leader"},{"content":"","permalink":"http://localhost:1313/search/","tags":null,"title":"Search"},{"content":"Hello, I’m Matteo Bisi.\nI’m a DevSecOps Team Leader currently living in Galway, Ireland, but originally from Italy.\nWith a passion for both technology and teamwork, I lead my team in building and securing cloud-native infrastructures using both open source and enterprise tools.\nMy journey has taken me across different roles, giving me a unique perspective on how diverse teams collaborate and innovate.\nI’m particularly interested in automating security practices, managing secrets at scale, and empowering development teams to deliver secure software efficiently.\nOutside of work, I enjoy exploring the beautiful Irish countryside, planning my next family trip, and cooking some Italian recipes.\nThrough this blog, I hope to share insights, best practices, and lessons learned from my experiences leading DevSecOps teams.\nYou can find more information about my CV on my LinkedIn profile.\nMy preavious blogs about Collaboration solutions are available here:\nitalian blog english blog ","permalink":"http://localhost:1313/aboutme/","tags":["biography"],"title":"About Me - Matteo Bisi"},{"content":"During the past few weeks, I have described what a secrets manager is and provided an overview of the architecture and system requirements of CyberArk Conjur.\nA secrets manager can’t do its job if it can’t communicate with those who need to request secrets, and that’s where Conjur’s magic comes in!\nThe “authenticators” are responsible for the authentication process in Conjur and are specialized to do this in the most secure way, depending on the service.\nHere is the list of authenticators currently supported:\nAuthenticator Description Row 1 Col 1 Defines the Conjur default authenticator. Authentication for both users and hosts is based on an ID and API key. Row 2 Col 1 Leverages the identity layer provided by OIDC to allow applications to authenticate with Conjur and retrieve secrets needed for connecting to services such as a database. Row 3 Col 1 Enables an AWS resource to use its AWS IAM role to authenticate with Conjur. Row 4 Col 1 Enables an Azure resource to authenticate with Conjur Row 5 Col 1 Enables an application to authenticate to Conjur using a JWT from a JWT Provider. Row 6 Col 1 Enables a Google Cloud Platform resource to authenticate with Conjur Row 7 Col 1 Authenticates hosts that are Kubernetes resources, such as a Kubernetes namespace, deployment, stateful set, and others. Authentication is certificate-based using a mutual TLS connection. Row 8 Col 1 Authenticates users based on an LDAP directory. ","permalink":"http://localhost:1313/posts/cyberark-conjur-authenticators-integrations/","tags":["conjur","authenticators","spiffe","integrations"],"title":"CyberArk Conjur , authenticators and integrations"},{"content":"As I wrote in my last post, CyberArk Conjur is an enterprise secrets manager. , CyberArk Conjur is an enterprise secrets manager.\nIn this post, I’ll provide an architecture overview along with the main system requirements.\nConjur is currently available in two versions: Enterprise and open source (known as OSS).\nA “cloud” version will be available soon, offered as a SaaS solution.\nThis post focuses on the Enterprise version, which is similar but not identical to the OSS version.\nArchitecture Conjur is distributed as a Docker image, making deployment and configuration fast and secure.\nThe main services included in the appliance image are:\nnginx: Provides access to the administrative GUI and the API set for interacting with secrets. PostgreSQL database: Two databases, one for configurations and secrets, and one for audit logs. Conjur appliance: The core product. syslog-ng: Used to collect audit and access logs. The smallest common configuration for Conjur Enterprise is a three-node cluster with auto-failover, as shown in the following diagram:\nThe cluster architecture follows an active-passive model, with high availability guaranteed by a load balancer placed in front of the cluster. This load balancer switches the node accessed by applications in case of a failure.\nWithin the cluster, one node acts as the “leader node,” handling all read/write operations and providing the API for applications to interact with secrets.\nThe secondary nodes are called “standbys” and can be either synchronous or asynchronous, depending on the PostgreSQL replication setup.\nThese nodes are inactive and do not provide API services.\nIf the leader node fails, after a configurable period, the standbys will elect a new leader using etcd and the Raft consensus algorithm.\nIf auto-failover is not configured, manual promotion is required.\nIt is also possible to configure a primary site with auto-failover and a secondary site with asynchronous standbys (without auto-failover), ready to be promoted manually.\nThe final component of the architecture is the “follower,” a read-only replica of the leader. Followers allow secrets to be read at scale and are horizontally scalable components typically configured behind a load balancer to handle all types of read requests, including authentication, permission checks, and secret fetches.\nFollowers are usually installed on a Kubernetes cluster to serve applications with low latency.\nThe architecture diagram with followers could be expanded as shown below:\nSystem Requirements Production environment:\n4 cores 8 GB RAM 50 GB hard drive Test environment:\n2 cores 4 GB RAM 20 GB hard drive Supported container runtimes:\nDocker 1.13 or later Mirantis Container Runtime (MRC) 19.x, 20.10 on RHEL 8.x Kubernetes and OpenShift (only for the follower) Podman 3.3 and 3.4 The host server should run an operating system supported by the container runtime (the most popular are RHEL Server, RHEL-based, or Ubuntu Server LTS). To read more detail or updated versions please refer to this page.\nIf the customer environment also includes a CyberArk Vault server that needs to be synchronized with Conjur, the following are the requirements for a CyberArk Vault Synchronizer server:\n4 cores 8 GB RAM Windows Server 2012 R2 or later ","permalink":"http://localhost:1313/posts/cyberark-conjur-architecture-system-requirements/","tags":["conjur","cyberark","secrets manager"],"title":"CyberArk Conjur: A Quick Overview of Architecture and System Requirements"},{"content":"Security is always a complex topic to address, as an error or omission in processes can lead to serious economic or reputational damage for a company.\nWhen we talk about “secrets,” consider the following examples:\nUsernames Database passwords SSL certificates and keys SSH keys Cloud credentials Simply reading through this list helps to explain why this topic needs to be considered and handled carefully.\nSome common bad practices or risks include:\nHardcoding secrets in code Data breaches Password leaks Secrets pushed to public repositories With practices like lateral movement, just one compromised secret can be enough to compromise an entire environment. To help prevent these risks, there are tools known as “enterprise secrets managers.” I’d like to start a series of posts on this blog about CyberArk Conjur.\nConjur allows you to avoid direct use of secrets by leveraging a set of REST APIs, making it a programmable tool that can be accessed via URL or open source utilities.\nSecurity is enforced through security policies without slowing down the developers involved.\nCorporate security can be further improved with the use of rotators, which programmatically change secret values.\nIf other CyberArk software like PAS Vault is already in use, Conjur can be integrated using the Synchroniser component,\nproviding the same level of security for cloud-native infrastructure.\nConjur is available in two versions: enterprise and open source, each with distinct features.\nIn upcoming posts, I will explain details about the architecture, secrets management, and product news related to CyberArk Conjur.\n","permalink":"http://localhost:1313/posts/why-you-need-kubernetes-secrets-manager/","tags":["conjur","introduction","secrets manager"],"title":"CyberArk Conjur - why you (probably) need an enterprise secrets manager"},{"content":"Hello there! How are you?\nI’m really good! As you may have seen on my social media, starting from the 16th of May, I’ve begun a new position as Senior DevSecOps at SIGHUP.\nI’m really excited about this new opportunity, and I’m writing this post because it will also have an effect on this blog’s focus.\nThe topics will shift from previous subjects to cloud-native infrastructure security, starting with tools like CyberArk Conjur. The previous content on this blog will remain here forever. I believe it could be helpful for some time, and I also want to honor my HCL Ambassador role.\nI’d also love to add that my current role as organizer of the LetsConnect user group will remain unchanged.\nI hope to see you all again at our next event!\n","permalink":"http://localhost:1313/posts/new-job-devsecops-teamleader/","tags":["cloudnative","newjob","devsecops","security"],"title":"I've started a new journey as DevSecOps Team Leader"},{"content":"","permalink":"http://localhost:1313/search/","tags":null,"title":"Search"},{"content":"Hello, I’m Matteo Bisi.\nI’m a DevSecOps Team Leader currently living in Galway, Ireland, but originally from Italy.\nWith a passion for both technology and teamwork, I lead my team in building and securing cloud-native infrastructures using both open source and enterprise tools.\nMy journey has taken me across different roles, giving me a unique perspective on how diverse teams collaborate and innovate.\nI’m particularly interested in automating security practices, managing secrets at scale, and empowering development teams to deliver secure software efficiently.\nOutside of work, I enjoy exploring the beautiful Irish countryside, planning my next family trip, and cooking some Italian recipes.\nThrough this blog, I hope to share insights, best practices, and lessons learned from my experiences leading DevSecOps teams.\nYou can find more information about my CV on my LinkedIn profile.\nMy preavious blogs about Collaboration solutions are available here:\nitalian blog english blog ","permalink":"http://localhost:1313/aboutme/","tags":["biography"],"title":"About Me - Matteo Bisi"},{"content":"During the past few weeks, I have described what a secrets manager is and provided an overview of the architecture and system requirements of CyberArk Conjur.\nA secrets manager can’t do its job if it can’t communicate with those who need to request secrets, and that’s where Conjur’s magic comes in!\nThe “authenticators” are responsible for the authentication process in Conjur and are specialized to do this in the most secure way, depending on the service.\nHere is the list of authenticators currently supported:\nAuthenticator Description authn Defines the Conjur default authenticator. Authentication for both users and hosts is based on an ID and API key. authn-oidc Leverages the identity layer provided by OIDC to allow applications to authenticate with Conjur and retrieve secrets needed for connecting to services such as a database. authn-iam Enables an AWS resource to use its AWS IAM role to authenticate with Conjur. authn-azure Enables an Azure resource to authenticate with Conjur authn-jwt Enables an application to authenticate to Conjur using a JWT from a JWT Provider. authn-gcp Enables a Google Cloud Platform resource to authenticate with Conjur authn-k8s Authenticates hosts that are Kubernetes resources, such as a Kubernetes namespace, deployment, stateful set, and others. Authentication is certificate-based using a mutual TLS connection. authn-ldap Authenticates users based on an LDAP directory. ","permalink":"http://localhost:1313/posts/cyberark-conjur-authenticators-integrations/","tags":["conjur","authenticators","spiffe","integrations"],"title":"CyberArk Conjur , authenticators and integrations"},{"content":"As I wrote in my last post, CyberArk Conjur is an enterprise secrets manager. , CyberArk Conjur is an enterprise secrets manager.\nIn this post, I’ll provide an architecture overview along with the main system requirements.\nConjur is currently available in two versions: Enterprise and open source (known as OSS).\nA “cloud” version will be available soon, offered as a SaaS solution.\nThis post focuses on the Enterprise version, which is similar but not identical to the OSS version.\nArchitecture Conjur is distributed as a Docker image, making deployment and configuration fast and secure.\nThe main services included in the appliance image are:\nnginx: Provides access to the administrative GUI and the API set for interacting with secrets. PostgreSQL database: Two databases, one for configurations and secrets, and one for audit logs. Conjur appliance: The core product. syslog-ng: Used to collect audit and access logs. The smallest common configuration for Conjur Enterprise is a three-node cluster with auto-failover, as shown in the following diagram:\nThe cluster architecture follows an active-passive model, with high availability guaranteed by a load balancer placed in front of the cluster. This load balancer switches the node accessed by applications in case of a failure.\nWithin the cluster, one node acts as the “leader node,” handling all read/write operations and providing the API for applications to interact with secrets.\nThe secondary nodes are called “standbys” and can be either synchronous or asynchronous, depending on the PostgreSQL replication setup.\nThese nodes are inactive and do not provide API services.\nIf the leader node fails, after a configurable period, the standbys will elect a new leader using etcd and the Raft consensus algorithm.\nIf auto-failover is not configured, manual promotion is required.\nIt is also possible to configure a primary site with auto-failover and a secondary site with asynchronous standbys (without auto-failover), ready to be promoted manually.\nThe final component of the architecture is the “follower,” a read-only replica of the leader. Followers allow secrets to be read at scale and are horizontally scalable components typically configured behind a load balancer to handle all types of read requests, including authentication, permission checks, and secret fetches.\nFollowers are usually installed on a Kubernetes cluster to serve applications with low latency.\nThe architecture diagram with followers could be expanded as shown below:\nSystem Requirements Production environment:\n4 cores 8 GB RAM 50 GB hard drive Test environment:\n2 cores 4 GB RAM 20 GB hard drive Supported container runtimes:\nDocker 1.13 or later Mirantis Container Runtime (MRC) 19.x, 20.10 on RHEL 8.x Kubernetes and OpenShift (only for the follower) Podman 3.3 and 3.4 The host server should run an operating system supported by the container runtime (the most popular are RHEL Server, RHEL-based, or Ubuntu Server LTS). To read more detail or updated versions please refer to this page.\nIf the customer environment also includes a CyberArk Vault server that needs to be synchronized with Conjur, the following are the requirements for a CyberArk Vault Synchronizer server:\n4 cores 8 GB RAM Windows Server 2012 R2 or later ","permalink":"http://localhost:1313/posts/cyberark-conjur-architecture-system-requirements/","tags":["conjur","cyberark","secrets manager"],"title":"CyberArk Conjur: A Quick Overview of Architecture and System Requirements"},{"content":"Security is always a complex topic to address, as an error or omission in processes can lead to serious economic or reputational damage for a company.\nWhen we talk about “secrets,” consider the following examples:\nUsernames Database passwords SSL certificates and keys SSH keys Cloud credentials Simply reading through this list helps to explain why this topic needs to be considered and handled carefully.\nSome common bad practices or risks include:\nHardcoding secrets in code Data breaches Password leaks Secrets pushed to public repositories With practices like lateral movement, just one compromised secret can be enough to compromise an entire environment. To help prevent these risks, there are tools known as “enterprise secrets managers.” I’d like to start a series of posts on this blog about CyberArk Conjur.\nConjur allows you to avoid direct use of secrets by leveraging a set of REST APIs, making it a programmable tool that can be accessed via URL or open source utilities.\nSecurity is enforced through security policies without slowing down the developers involved.\nCorporate security can be further improved with the use of rotators, which programmatically change secret values.\nIf other CyberArk software like PAS Vault is already in use, Conjur can be integrated using the Synchroniser component,\nproviding the same level of security for cloud-native infrastructure.\nConjur is available in two versions: enterprise and open source, each with distinct features.\nIn upcoming posts, I will explain details about the architecture, secrets management, and product news related to CyberArk Conjur.\n","permalink":"http://localhost:1313/posts/why-you-need-kubernetes-secrets-manager/","tags":["conjur","introduction","secrets manager"],"title":"CyberArk Conjur - why you (probably) need an enterprise secrets manager"},{"content":"Hello there! How are you?\nI’m really good! As you may have seen on my social media, starting from the 16th of May, I’ve begun a new position as Senior DevSecOps at SIGHUP.\nI’m really excited about this new opportunity, and I’m writing this post because it will also have an effect on this blog’s focus.\nThe topics will shift from previous subjects to cloud-native infrastructure security, starting with tools like CyberArk Conjur. The previous content on this blog will remain here forever. I believe it could be helpful for some time, and I also want to honor my HCL Ambassador role.\nI’d also love to add that my current role as organizer of the LetsConnect user group will remain unchanged.\nI hope to see you all again at our next event!\n","permalink":"http://localhost:1313/posts/new-job-devsecops-teamleader/","tags":["cloudnative","newjob","devsecops","security"],"title":"I've started a new journey as DevSecOps Team Leader"},{"content":"","permalink":"http://localhost:1313/search/","tags":null,"title":"Search"},{"content":"Hello, I’m Matteo Bisi.\nI’m a DevSecOps Team Leader currently living in Galway, Ireland, but originally from Italy.\nWith a passion for both technology and teamwork, I lead my team in building and securing cloud-native infrastructures using both open source and enterprise tools.\nMy journey has taken me across different roles, giving me a unique perspective on how diverse teams collaborate and innovate.\nI’m particularly interested in automating security practices, managing secrets at scale, and empowering development teams to deliver secure software efficiently.\nOutside of work, I enjoy exploring the beautiful Irish countryside, planning my next family trip, and cooking some Italian recipes.\nThrough this blog, I hope to share insights, best practices, and lessons learned from my experiences leading DevSecOps teams.\nYou can find more information about my CV on my LinkedIn profile.\nMy preavious blogs about Collaboration solutions are available here:\nitalian blog english blog ","permalink":"http://localhost:1313/aboutme/","tags":["biography"],"title":"About Me - Matteo Bisi"},{"content":"During the past few weeks, I have described what a secrets manager is and provided an overview of the architecture and system requirements of CyberArk Conjur.\nA secrets manager can’t do its job if it can’t communicate with those who need to request secrets, and that’s where Conjur’s magic comes in!\nThe “authenticators” are responsible for the authentication process in Conjur and are specialized to do this in the most secure way, depending on the service.\nHere is the list of authenticators currently supported:\nAuthenticator Description authn Defines the Conjur default authenticator. Authentication for both users and hosts is based on an ID and API key. authn-oidc Leverages the identity layer provided by OIDC to allow applications to authenticate with Conjur and retrieve secrets needed for connecting to services such as a database. [authn-iam(https://docs.cyberark.com/Product-Doc/OnlineHelp/AAM-DAP/Latest/en/Content/Operations/Services/AWS_IAM_Authenticator.htm)] Enables an AWS resource to use its AWS IAM role to authenticate with Conjur. authn-azure Enables an Azure resource to authenticate with Conjur authn-jwt Enables an application to authenticate to Conjur using a JWT from a JWT Provider. authn-gcp Enables a Google Cloud Platform resource to authenticate with Conjur authn-k8s Authenticates hosts that are Kubernetes resources, such as a Kubernetes namespace, deployment, stateful set, and others. Authentication is certificate-based using a mutual TLS connection. authn-ldap Authenticates users based on an LDAP directory. ","permalink":"http://localhost:1313/posts/cyberark-conjur-authenticators-integrations/","tags":["conjur","authenticators","spiffe","integrations"],"title":"CyberArk Conjur , authenticators and integrations"},{"content":"As I wrote in my last post, CyberArk Conjur is an enterprise secrets manager. , CyberArk Conjur is an enterprise secrets manager.\nIn this post, I’ll provide an architecture overview along with the main system requirements.\nConjur is currently available in two versions: Enterprise and open source (known as OSS).\nA “cloud” version will be available soon, offered as a SaaS solution.\nThis post focuses on the Enterprise version, which is similar but not identical to the OSS version.\nArchitecture Conjur is distributed as a Docker image, making deployment and configuration fast and secure.\nThe main services included in the appliance image are:\nnginx: Provides access to the administrative GUI and the API set for interacting with secrets. PostgreSQL database: Two databases, one for configurations and secrets, and one for audit logs. Conjur appliance: The core product. syslog-ng: Used to collect audit and access logs. The smallest common configuration for Conjur Enterprise is a three-node cluster with auto-failover, as shown in the following diagram:\nThe cluster architecture follows an active-passive model, with high availability guaranteed by a load balancer placed in front of the cluster. This load balancer switches the node accessed by applications in case of a failure.\nWithin the cluster, one node acts as the “leader node,” handling all read/write operations and providing the API for applications to interact with secrets.\nThe secondary nodes are called “standbys” and can be either synchronous or asynchronous, depending on the PostgreSQL replication setup.\nThese nodes are inactive and do not provide API services.\nIf the leader node fails, after a configurable period, the standbys will elect a new leader using etcd and the Raft consensus algorithm.\nIf auto-failover is not configured, manual promotion is required.\nIt is also possible to configure a primary site with auto-failover and a secondary site with asynchronous standbys (without auto-failover), ready to be promoted manually.\nThe final component of the architecture is the “follower,” a read-only replica of the leader. Followers allow secrets to be read at scale and are horizontally scalable components typically configured behind a load balancer to handle all types of read requests, including authentication, permission checks, and secret fetches.\nFollowers are usually installed on a Kubernetes cluster to serve applications with low latency.\nThe architecture diagram with followers could be expanded as shown below:\nSystem Requirements Production environment:\n4 cores 8 GB RAM 50 GB hard drive Test environment:\n2 cores 4 GB RAM 20 GB hard drive Supported container runtimes:\nDocker 1.13 or later Mirantis Container Runtime (MRC) 19.x, 20.10 on RHEL 8.x Kubernetes and OpenShift (only for the follower) Podman 3.3 and 3.4 The host server should run an operating system supported by the container runtime (the most popular are RHEL Server, RHEL-based, or Ubuntu Server LTS). To read more detail or updated versions please refer to this page.\nIf the customer environment also includes a CyberArk Vault server that needs to be synchronized with Conjur, the following are the requirements for a CyberArk Vault Synchronizer server:\n4 cores 8 GB RAM Windows Server 2012 R2 or later ","permalink":"http://localhost:1313/posts/cyberark-conjur-architecture-system-requirements/","tags":["conjur","cyberark","secrets manager"],"title":"CyberArk Conjur: A Quick Overview of Architecture and System Requirements"},{"content":"Security is always a complex topic to address, as an error or omission in processes can lead to serious economic or reputational damage for a company.\nWhen we talk about “secrets,” consider the following examples:\nUsernames Database passwords SSL certificates and keys SSH keys Cloud credentials Simply reading through this list helps to explain why this topic needs to be considered and handled carefully.\nSome common bad practices or risks include:\nHardcoding secrets in code Data breaches Password leaks Secrets pushed to public repositories With practices like lateral movement, just one compromised secret can be enough to compromise an entire environment. To help prevent these risks, there are tools known as “enterprise secrets managers.” I’d like to start a series of posts on this blog about CyberArk Conjur.\nConjur allows you to avoid direct use of secrets by leveraging a set of REST APIs, making it a programmable tool that can be accessed via URL or open source utilities.\nSecurity is enforced through security policies without slowing down the developers involved.\nCorporate security can be further improved with the use of rotators, which programmatically change secret values.\nIf other CyberArk software like PAS Vault is already in use, Conjur can be integrated using the Synchroniser component,\nproviding the same level of security for cloud-native infrastructure.\nConjur is available in two versions: enterprise and open source, each with distinct features.\nIn upcoming posts, I will explain details about the architecture, secrets management, and product news related to CyberArk Conjur.\n","permalink":"http://localhost:1313/posts/why-you-need-kubernetes-secrets-manager/","tags":["conjur","introduction","secrets manager"],"title":"CyberArk Conjur - why you (probably) need an enterprise secrets manager"},{"content":"Hello there! How are you?\nI’m really good! As you may have seen on my social media, starting from the 16th of May, I’ve begun a new position as Senior DevSecOps at SIGHUP.\nI’m really excited about this new opportunity, and I’m writing this post because it will also have an effect on this blog’s focus.\nThe topics will shift from previous subjects to cloud-native infrastructure security, starting with tools like CyberArk Conjur. The previous content on this blog will remain here forever. I believe it could be helpful for some time, and I also want to honor my HCL Ambassador role.\nI’d also love to add that my current role as organizer of the LetsConnect user group will remain unchanged.\nI hope to see you all again at our next event!\n","permalink":"http://localhost:1313/posts/new-job-devsecops-teamleader/","tags":["cloudnative","newjob","devsecops","security"],"title":"I've started a new journey as DevSecOps Team Leader"},{"content":"","permalink":"http://localhost:1313/search/","tags":null,"title":"Search"},{"content":"Hello, I’m Matteo Bisi.\nI’m a DevSecOps Team Leader currently living in Galway, Ireland, but originally from Italy.\nWith a passion for both technology and teamwork, I lead my team in building and securing cloud-native infrastructures using both open source and enterprise tools.\nMy journey has taken me across different roles, giving me a unique perspective on how diverse teams collaborate and innovate.\nI’m particularly interested in automating security practices, managing secrets at scale, and empowering development teams to deliver secure software efficiently.\nOutside of work, I enjoy exploring the beautiful Irish countryside, planning my next family trip, and cooking some Italian recipes.\nThrough this blog, I hope to share insights, best practices, and lessons learned from my experiences leading DevSecOps teams.\nYou can find more information about my CV on my LinkedIn profile.\nMy preavious blogs about Collaboration solutions are available here:\nitalian blog english blog ","permalink":"http://localhost:1313/aboutme/","tags":["biography"],"title":"About Me - Matteo Bisi"},{"content":"During the past few weeks, I have described what a secrets manager is and provided an overview of the architecture and system requirements of CyberArk Conjur.\nA secrets manager can’t do its job if it can’t communicate with those who need to request secrets, and that’s where Conjur’s magic comes in!\nThe “authenticators” are responsible for the authentication process in Conjur and are specialized to do this in the most secure way, depending on the service.\nHere is the list of authenticators currently supported:\nAuthenticator Description authn Defines the Conjur default authenticator. Authentication for both users and hosts is based on an ID and API key. authn-oidc Leverages the identity layer provided by OIDC to allow applications to authenticate with Conjur and retrieve secrets needed for connecting to services such as a database. [authn-iam(https://docs.cyberark.com/Product-Doc/OnlineHelp/AAM-DAP/Latest/en/Content/Operations/Services/AWS_IAM_Authenticator.htm)] Enables an AWS resource to use its AWS IAM role to authenticate with Conjur. authn-azure Enables an Azure resource to authenticate with Conjur authn-jwt Enables an application to authenticate to Conjur using a JWT from a JWT Provider. authn-gcp Enables a Google Cloud Platform resource to authenticate with Conjur authn-k8s Authenticates hosts that are Kubernetes resources, such as a Kubernetes namespace, deployment, stateful set, and others. Authentication is certificate-based using a mutual TLS connection. authn-ldap Authenticates users based on an LDAP directory. By default, after the initial setup, authn is the only authenticator enabled, and it is responsible for Conjur access using a username or API key (randomly generated between 51 and 56 characters).\nWhen integrations are needed, for example with a Kubernetes cluster, you need to activate and configure the authn-k8s authenticator. This authenticator can establish a secure mTLS connection compliant with the SPIFFE framework, as described in the following diagram (click here for more details):\n","permalink":"http://localhost:1313/posts/cyberark-conjur-authenticators-integrations/","tags":["conjur","authenticators","spiffe","integrations"],"title":"CyberArk Conjur , authenticators and integrations"},{"content":"As I wrote in my last post, CyberArk Conjur is an enterprise secrets manager. , CyberArk Conjur is an enterprise secrets manager.\nIn this post, I’ll provide an architecture overview along with the main system requirements.\nConjur is currently available in two versions: Enterprise and open source (known as OSS).\nA “cloud” version will be available soon, offered as a SaaS solution.\nThis post focuses on the Enterprise version, which is similar but not identical to the OSS version.\nArchitecture Conjur is distributed as a Docker image, making deployment and configuration fast and secure.\nThe main services included in the appliance image are:\nnginx: Provides access to the administrative GUI and the API set for interacting with secrets. PostgreSQL database: Two databases, one for configurations and secrets, and one for audit logs. Conjur appliance: The core product. syslog-ng: Used to collect audit and access logs. The smallest common configuration for Conjur Enterprise is a three-node cluster with auto-failover, as shown in the following diagram:\nThe cluster architecture follows an active-passive model, with high availability guaranteed by a load balancer placed in front of the cluster. This load balancer switches the node accessed by applications in case of a failure.\nWithin the cluster, one node acts as the “leader node,” handling all read/write operations and providing the API for applications to interact with secrets.\nThe secondary nodes are called “standbys” and can be either synchronous or asynchronous, depending on the PostgreSQL replication setup.\nThese nodes are inactive and do not provide API services.\nIf the leader node fails, after a configurable period, the standbys will elect a new leader using etcd and the Raft consensus algorithm.\nIf auto-failover is not configured, manual promotion is required.\nIt is also possible to configure a primary site with auto-failover and a secondary site with asynchronous standbys (without auto-failover), ready to be promoted manually.\nThe final component of the architecture is the “follower,” a read-only replica of the leader. Followers allow secrets to be read at scale and are horizontally scalable components typically configured behind a load balancer to handle all types of read requests, including authentication, permission checks, and secret fetches.\nFollowers are usually installed on a Kubernetes cluster to serve applications with low latency.\nThe architecture diagram with followers could be expanded as shown below:\nSystem Requirements Production environment:\n4 cores 8 GB RAM 50 GB hard drive Test environment:\n2 cores 4 GB RAM 20 GB hard drive Supported container runtimes:\nDocker 1.13 or later Mirantis Container Runtime (MRC) 19.x, 20.10 on RHEL 8.x Kubernetes and OpenShift (only for the follower) Podman 3.3 and 3.4 The host server should run an operating system supported by the container runtime (the most popular are RHEL Server, RHEL-based, or Ubuntu Server LTS). To read more detail or updated versions please refer to this page.\nIf the customer environment also includes a CyberArk Vault server that needs to be synchronized with Conjur, the following are the requirements for a CyberArk Vault Synchronizer server:\n4 cores 8 GB RAM Windows Server 2012 R2 or later ","permalink":"http://localhost:1313/posts/cyberark-conjur-architecture-system-requirements/","tags":["conjur","cyberark","secrets manager"],"title":"CyberArk Conjur: A Quick Overview of Architecture and System Requirements"},{"content":"Security is always a complex topic to address, as an error or omission in processes can lead to serious economic or reputational damage for a company.\nWhen we talk about “secrets,” consider the following examples:\nUsernames Database passwords SSL certificates and keys SSH keys Cloud credentials Simply reading through this list helps to explain why this topic needs to be considered and handled carefully.\nSome common bad practices or risks include:\nHardcoding secrets in code Data breaches Password leaks Secrets pushed to public repositories With practices like lateral movement, just one compromised secret can be enough to compromise an entire environment. To help prevent these risks, there are tools known as “enterprise secrets managers.” I’d like to start a series of posts on this blog about CyberArk Conjur.\nConjur allows you to avoid direct use of secrets by leveraging a set of REST APIs, making it a programmable tool that can be accessed via URL or open source utilities.\nSecurity is enforced through security policies without slowing down the developers involved.\nCorporate security can be further improved with the use of rotators, which programmatically change secret values.\nIf other CyberArk software like PAS Vault is already in use, Conjur can be integrated using the Synchroniser component,\nproviding the same level of security for cloud-native infrastructure.\nConjur is available in two versions: enterprise and open source, each with distinct features.\nIn upcoming posts, I will explain details about the architecture, secrets management, and product news related to CyberArk Conjur.\n","permalink":"http://localhost:1313/posts/why-you-need-kubernetes-secrets-manager/","tags":["conjur","introduction","secrets manager"],"title":"CyberArk Conjur - why you (probably) need an enterprise secrets manager"},{"content":"Hello there! How are you?\nI’m really good! As you may have seen on my social media, starting from the 16th of May, I’ve begun a new position as Senior DevSecOps at SIGHUP.\nI’m really excited about this new opportunity, and I’m writing this post because it will also have an effect on this blog’s focus.\nThe topics will shift from previous subjects to cloud-native infrastructure security, starting with tools like CyberArk Conjur. The previous content on this blog will remain here forever. I believe it could be helpful for some time, and I also want to honor my HCL Ambassador role.\nI’d also love to add that my current role as organizer of the LetsConnect user group will remain unchanged.\nI hope to see you all again at our next event!\n","permalink":"http://localhost:1313/posts/new-job-devsecops-teamleader/","tags":["cloudnative","newjob","devsecops","security"],"title":"I've started a new journey as DevSecOps Team Leader"},{"content":"","permalink":"http://localhost:1313/search/","tags":null,"title":"Search"},{"content":"Hello, I’m Matteo Bisi.\nI’m a DevSecOps Team Leader currently living in Galway, Ireland, but originally from Italy.\nWith a passion for both technology and teamwork, I lead my team in building and securing cloud-native infrastructures using both open source and enterprise tools.\nMy journey has taken me across different roles, giving me a unique perspective on how diverse teams collaborate and innovate.\nI’m particularly interested in automating security practices, managing secrets at scale, and empowering development teams to deliver secure software efficiently.\nOutside of work, I enjoy exploring the beautiful Irish countryside, planning my next family trip, and cooking some Italian recipes.\nThrough this blog, I hope to share insights, best practices, and lessons learned from my experiences leading DevSecOps teams.\nYou can find more information about my CV on my LinkedIn profile.\nMy preavious blogs about Collaboration solutions are available here:\nitalian blog english blog ","permalink":"http://localhost:1313/aboutme/","tags":["biography"],"title":"About Me - Matteo Bisi"},{"content":"During the past few weeks, I have described what a secrets manager is and provided an overview of the architecture and system requirements of CyberArk Conjur.\nA secrets manager can’t do its job if it can’t communicate with those who need to request secrets, and that’s where Conjur’s magic comes in!\nThe “authenticators” are responsible for the authentication process in Conjur and are specialized to do this in the most secure way, depending on the service.\nHere is the list of authenticators currently supported:\nAuthenticator Description authn Defines the Conjur default authenticator. Authentication for both users and hosts is based on an ID and API key. authn-oidc Leverages the identity layer provided by OIDC to allow applications to authenticate with Conjur and retrieve secrets needed for connecting to services such as a database. [authn-iam(https://docs.cyberark.com/Product-Doc/OnlineHelp/AAM-DAP/Latest/en/Content/Operations/Services/AWS_IAM_Authenticator.htm)] Enables an AWS resource to use its AWS IAM role to authenticate with Conjur. authn-azure Enables an Azure resource to authenticate with Conjur authn-jwt Enables an application to authenticate to Conjur using a JWT from a JWT Provider. authn-gcp Enables a Google Cloud Platform resource to authenticate with Conjur authn-k8s Authenticates hosts that are Kubernetes resources, such as a Kubernetes namespace, deployment, stateful set, and others. Authentication is certificate-based using a mutual TLS connection. authn-ldap Authenticates users based on an LDAP directory. By default, after the initial setup, authn is the only authenticator enabled, and it is responsible for Conjur access using a username or API key (randomly generated between 51 and 56 characters).\nWhen integrations are needed, for example with a Kubernetes cluster, you need to activate and configure the authn-k8s authenticator. This authenticator can establish a secure mTLS connection compliant with the SPIFFE framework, as described in the following diagram (click here for more details):\n","permalink":"http://localhost:1313/posts/cyberark-conjur-authenticators-integrations/","tags":["conjur","authenticators","spiffe","integrations"],"title":"CyberArk Conjur , authenticators and integrations"},{"content":"As I wrote in my last post, CyberArk Conjur is an enterprise secrets manager. , CyberArk Conjur is an enterprise secrets manager.\nIn this post, I’ll provide an architecture overview along with the main system requirements.\nConjur is currently available in two versions: Enterprise and open source (known as OSS).\nA “cloud” version will be available soon, offered as a SaaS solution.\nThis post focuses on the Enterprise version, which is similar but not identical to the OSS version.\nArchitecture Conjur is distributed as a Docker image, making deployment and configuration fast and secure.\nThe main services included in the appliance image are:\nnginx: Provides access to the administrative GUI and the API set for interacting with secrets. PostgreSQL database: Two databases, one for configurations and secrets, and one for audit logs. Conjur appliance: The core product. syslog-ng: Used to collect audit and access logs. The smallest common configuration for Conjur Enterprise is a three-node cluster with auto-failover, as shown in the following diagram:\nThe cluster architecture follows an active-passive model, with high availability guaranteed by a load balancer placed in front of the cluster. This load balancer switches the node accessed by applications in case of a failure.\nWithin the cluster, one node acts as the “leader node,” handling all read/write operations and providing the API for applications to interact with secrets.\nThe secondary nodes are called “standbys” and can be either synchronous or asynchronous, depending on the PostgreSQL replication setup.\nThese nodes are inactive and do not provide API services.\nIf the leader node fails, after a configurable period, the standbys will elect a new leader using etcd and the Raft consensus algorithm.\nIf auto-failover is not configured, manual promotion is required.\nIt is also possible to configure a primary site with auto-failover and a secondary site with asynchronous standbys (without auto-failover), ready to be promoted manually.\nThe final component of the architecture is the “follower,” a read-only replica of the leader. Followers allow secrets to be read at scale and are horizontally scalable components typically configured behind a load balancer to handle all types of read requests, including authentication, permission checks, and secret fetches.\nFollowers are usually installed on a Kubernetes cluster to serve applications with low latency.\nThe architecture diagram with followers could be expanded as shown below:\nSystem Requirements Production environment:\n4 cores 8 GB RAM 50 GB hard drive Test environment:\n2 cores 4 GB RAM 20 GB hard drive Supported container runtimes:\nDocker 1.13 or later Mirantis Container Runtime (MRC) 19.x, 20.10 on RHEL 8.x Kubernetes and OpenShift (only for the follower) Podman 3.3 and 3.4 The host server should run an operating system supported by the container runtime (the most popular are RHEL Server, RHEL-based, or Ubuntu Server LTS). To read more detail or updated versions please refer to this page.\nIf the customer environment also includes a CyberArk Vault server that needs to be synchronized with Conjur, the following are the requirements for a CyberArk Vault Synchronizer server:\n4 cores 8 GB RAM Windows Server 2012 R2 or later ","permalink":"http://localhost:1313/posts/cyberark-conjur-architecture-system-requirements/","tags":["conjur","cyberark","secrets manager"],"title":"CyberArk Conjur: A Quick Overview of Architecture and System Requirements"},{"content":"Security is always a complex topic to address, as an error or omission in processes can lead to serious economic or reputational damage for a company.\nWhen we talk about “secrets,” consider the following examples:\nUsernames Database passwords SSL certificates and keys SSH keys Cloud credentials Simply reading through this list helps to explain why this topic needs to be considered and handled carefully.\nSome common bad practices or risks include:\nHardcoding secrets in code Data breaches Password leaks Secrets pushed to public repositories With practices like lateral movement, just one compromised secret can be enough to compromise an entire environment. To help prevent these risks, there are tools known as “enterprise secrets managers.” I’d like to start a series of posts on this blog about CyberArk Conjur.\nConjur allows you to avoid direct use of secrets by leveraging a set of REST APIs, making it a programmable tool that can be accessed via URL or open source utilities.\nSecurity is enforced through security policies without slowing down the developers involved.\nCorporate security can be further improved with the use of rotators, which programmatically change secret values.\nIf other CyberArk software like PAS Vault is already in use, Conjur can be integrated using the Synchroniser component,\nproviding the same level of security for cloud-native infrastructure.\nConjur is available in two versions: enterprise and open source, each with distinct features.\nIn upcoming posts, I will explain details about the architecture, secrets management, and product news related to CyberArk Conjur.\n","permalink":"http://localhost:1313/posts/why-you-need-kubernetes-secrets-manager/","tags":["conjur","introduction","secrets manager"],"title":"CyberArk Conjur - why you (probably) need an enterprise secrets manager"},{"content":"Hello there! How are you?\nI’m really good! As you may have seen on my social media, starting from the 16th of May, I’ve begun a new position as Senior DevSecOps at SIGHUP.\nI’m really excited about this new opportunity, and I’m writing this post because it will also have an effect on this blog’s focus.\nThe topics will shift from previous subjects to cloud-native infrastructure security, starting with tools like CyberArk Conjur. The previous content on this blog will remain here forever. I believe it could be helpful for some time, and I also want to honor my HCL Ambassador role.\nI’d also love to add that my current role as organizer of the LetsConnect user group will remain unchanged.\nI hope to see you all again at our next event!\n","permalink":"http://localhost:1313/posts/new-job-devsecops-teamleader/","tags":["cloudnative","newjob","devsecops","security"],"title":"I've started a new journey as DevSecOps Team Leader"},{"content":"","permalink":"http://localhost:1313/search/","tags":null,"title":"Search"},{"content":"Hello, I’m Matteo Bisi.\nI’m a DevSecOps Team Leader currently living in Galway, Ireland, but originally from Italy.\nWith a passion for both technology and teamwork, I lead my team in building and securing cloud-native infrastructures using both open source and enterprise tools.\nMy journey has taken me across different roles, giving me a unique perspective on how diverse teams collaborate and innovate.\nI’m particularly interested in automating security practices, managing secrets at scale, and empowering development teams to deliver secure software efficiently.\nOutside of work, I enjoy exploring the beautiful Irish countryside, planning my next family trip, and cooking some Italian recipes.\nThrough this blog, I hope to share insights, best practices, and lessons learned from my experiences leading DevSecOps teams.\nYou can find more information about my CV on my LinkedIn profile.\nMy preavious blogs about Collaboration solutions are available here:\nitalian blog english blog ","permalink":"http://localhost:1313/aboutme/","tags":["biography"],"title":"About Me - Matteo Bisi"},{"content":"During the past few weeks, I have described what a secrets manager is and provided an overview of the architecture and system requirements of CyberArk Conjur.\nA secrets manager can’t do its job if it can’t communicate with those who need to request secrets, and that’s where Conjur’s magic comes in!\nThe “authenticators” are responsible for the authentication process in Conjur and are specialized to do this in the most secure way, depending on the service.\nHere is the list of authenticators currently supported:\nAuthenticator Description authn Defines the Conjur default authenticator. Authentication for both users and hosts is based on an ID and API key. authn-oidc Leverages the identity layer provided by OIDC to allow applications to authenticate with Conjur and retrieve secrets needed for connecting to services such as a database. [authn-iam(https://docs.cyberark.com/Product-Doc/OnlineHelp/AAM-DAP/Latest/en/Content/Operations/Services/AWS_IAM_Authenticator.htm)] Enables an AWS resource to use its AWS IAM role to authenticate with Conjur. authn-azure Enables an Azure resource to authenticate with Conjur authn-jwt Enables an application to authenticate to Conjur using a JWT from a JWT Provider. authn-gcp Enables a Google Cloud Platform resource to authenticate with Conjur authn-k8s Authenticates hosts that are Kubernetes resources, such as a Kubernetes namespace, deployment, stateful set, and others. Authentication is certificate-based using a mutual TLS connection. authn-ldap Authenticates users based on an LDAP directory. By default, after the initial setup, authn is the only authenticator enabled, and it is responsible for Conjur access using a username or API key (randomly generated between 51 and 56 characters).\nWhen integrations are needed, for example with a Kubernetes cluster, you need to activate and configure the authn-k8s authenticator. This authenticator can establish a secure mTLS connection compliant with the SPIFFE framework, as described in the following diagram (click here for more details):\n","permalink":"http://localhost:1313/posts/cyberark-conjur-authenticators-integrations/","tags":["conjur","authenticators","spiffe","integrations"],"title":"CyberArk Conjur , authenticators and integrations"},{"content":"As I wrote in my last post, CyberArk Conjur is an enterprise secrets manager. , CyberArk Conjur is an enterprise secrets manager.\nIn this post, I’ll provide an architecture overview along with the main system requirements.\nConjur is currently available in two versions: Enterprise and open source (known as OSS).\nA “cloud” version will be available soon, offered as a SaaS solution.\nThis post focuses on the Enterprise version, which is similar but not identical to the OSS version.\nArchitecture Conjur is distributed as a Docker image, making deployment and configuration fast and secure.\nThe main services included in the appliance image are:\nnginx: Provides access to the administrative GUI and the API set for interacting with secrets. PostgreSQL database: Two databases, one for configurations and secrets, and one for audit logs. Conjur appliance: The core product. syslog-ng: Used to collect audit and access logs. The smallest common configuration for Conjur Enterprise is a three-node cluster with auto-failover, as shown in the following diagram:\nThe cluster architecture follows an active-passive model, with high availability guaranteed by a load balancer placed in front of the cluster. This load balancer switches the node accessed by applications in case of a failure.\nWithin the cluster, one node acts as the “leader node,” handling all read/write operations and providing the API for applications to interact with secrets.\nThe secondary nodes are called “standbys” and can be either synchronous or asynchronous, depending on the PostgreSQL replication setup.\nThese nodes are inactive and do not provide API services.\nIf the leader node fails, after a configurable period, the standbys will elect a new leader using etcd and the Raft consensus algorithm.\nIf auto-failover is not configured, manual promotion is required.\nIt is also possible to configure a primary site with auto-failover and a secondary site with asynchronous standbys (without auto-failover), ready to be promoted manually.\nThe final component of the architecture is the “follower,” a read-only replica of the leader. Followers allow secrets to be read at scale and are horizontally scalable components typically configured behind a load balancer to handle all types of read requests, including authentication, permission checks, and secret fetches.\nFollowers are usually installed on a Kubernetes cluster to serve applications with low latency.\nThe architecture diagram with followers could be expanded as shown below:\nSystem Requirements Production environment:\n4 cores 8 GB RAM 50 GB hard drive Test environment:\n2 cores 4 GB RAM 20 GB hard drive Supported container runtimes:\nDocker 1.13 or later Mirantis Container Runtime (MRC) 19.x, 20.10 on RHEL 8.x Kubernetes and OpenShift (only for the follower) Podman 3.3 and 3.4 The host server should run an operating system supported by the container runtime (the most popular are RHEL Server, RHEL-based, or Ubuntu Server LTS). To read more detail or updated versions please refer to this page.\nIf the customer environment also includes a CyberArk Vault server that needs to be synchronized with Conjur, the following are the requirements for a CyberArk Vault Synchronizer server:\n4 cores 8 GB RAM Windows Server 2012 R2 or later ","permalink":"http://localhost:1313/posts/cyberark-conjur-architecture-system-requirements/","tags":["conjur","cyberark","secrets manager"],"title":"CyberArk Conjur: A Quick Overview of Architecture and System Requirements"},{"content":"Security is always a complex topic to address, as an error or omission in processes can lead to serious economic or reputational damage for a company.\nWhen we talk about “secrets,” consider the following examples:\nUsernames Database passwords SSL certificates and keys SSH keys Cloud credentials Simply reading through this list helps to explain why this topic needs to be considered and handled carefully.\nSome common bad practices or risks include:\nHardcoding secrets in code Data breaches Password leaks Secrets pushed to public repositories With practices like lateral movement, just one compromised secret can be enough to compromise an entire environment. To help prevent these risks, there are tools known as “enterprise secrets managers.” I’d like to start a series of posts on this blog about CyberArk Conjur.\nConjur allows you to avoid direct use of secrets by leveraging a set of REST APIs, making it a programmable tool that can be accessed via URL or open source utilities.\nSecurity is enforced through security policies without slowing down the developers involved.\nCorporate security can be further improved with the use of rotators, which programmatically change secret values.\nIf other CyberArk software like PAS Vault is already in use, Conjur can be integrated using the Synchroniser component,\nproviding the same level of security for cloud-native infrastructure.\nConjur is available in two versions: enterprise and open source, each with distinct features.\nIn upcoming posts, I will explain details about the architecture, secrets management, and product news related to CyberArk Conjur.\n","permalink":"http://localhost:1313/posts/why-you-need-kubernetes-secrets-manager/","tags":["conjur","introduction","secrets manager"],"title":"CyberArk Conjur - why you (probably) need an enterprise secrets manager"},{"content":"Hello there! How are you?\nI’m really good! As you may have seen on my social media, starting from the 16th of May, I’ve begun a new position as Senior DevSecOps at SIGHUP.\nI’m really excited about this new opportunity, and I’m writing this post because it will also have an effect on this blog’s focus.\nThe topics will shift from previous subjects to cloud-native infrastructure security, starting with tools like CyberArk Conjur. The previous content on this blog will remain here forever. I believe it could be helpful for some time, and I also want to honor my HCL Ambassador role.\nI’d also love to add that my current role as organizer of the LetsConnect user group will remain unchanged.\nI hope to see you all again at our next event!\n","permalink":"http://localhost:1313/posts/new-job-devsecops-teamleader/","tags":["cloudnative","newjob","devsecops","security"],"title":"I've started a new journey as DevSecOps Team Leader"},{"content":"","permalink":"http://localhost:1313/search/","tags":null,"title":"Search"},{"content":"Hello, I’m Matteo Bisi.\nI’m a DevSecOps Team Leader currently living in Galway, Ireland, but originally from Italy.\nWith a passion for both technology and teamwork, I lead my team in building and securing cloud-native infrastructures using both open source and enterprise tools.\nMy journey has taken me across different roles, giving me a unique perspective on how diverse teams collaborate and innovate.\nI’m particularly interested in automating security practices, managing secrets at scale, and empowering development teams to deliver secure software efficiently.\nOutside of work, I enjoy exploring the beautiful Irish countryside, planning my next family trip, and cooking some Italian recipes.\nThrough this blog, I hope to share insights, best practices, and lessons learned from my experiences leading DevSecOps teams.\nYou can find more information about my CV on my LinkedIn profile.\nMy preavious blogs about Collaboration solutions are available here:\nitalian blog english blog ","permalink":"http://localhost:1313/aboutme/","tags":["biography"],"title":"About Me - Matteo Bisi"},{"content":"During the past few weeks, I have described what a secrets manager is and provided an overview of the architecture and system requirements of CyberArk Conjur.\nA secrets manager can’t do its job if it can’t communicate with those who need to request secrets, and that’s where Conjur’s magic comes in!\nThe “authenticators” are responsible for the authentication process in Conjur and are specialized to do this in the most secure way, depending on the service.\nHere is the list of authenticators currently supported:\nAuthenticator Description authn Defines the Conjur default authenticator. Authentication for both users and hosts is based on an ID and API key. authn-oidc Leverages the identity layer provided by OIDC to allow applications to authenticate with Conjur and retrieve secrets needed for connecting to services such as a database. [authn-iam(https://docs.cyberark.com/Product-Doc/OnlineHelp/AAM-DAP/Latest/en/Content/Operations/Services/AWS_IAM_Authenticator.htm)] Enables an AWS resource to use its AWS IAM role to authenticate with Conjur. authn-azure Enables an Azure resource to authenticate with Conjur authn-jwt Enables an application to authenticate to Conjur using a JWT from a JWT Provider. authn-gcp Enables a Google Cloud Platform resource to authenticate with Conjur authn-k8s Authenticates hosts that are Kubernetes resources, such as a Kubernetes namespace, deployment, stateful set, and others. Authentication is certificate-based using a mutual TLS connection. authn-ldap Authenticates users based on an LDAP directory. By default, after the initial setup, authn is the only authenticator enabled, and it is responsible for Conjur access using a username or API key (randomly generated between 51 and 56 characters).\nWhen integrations are needed, for example with a Kubernetes cluster, you need to activate and configure the authn-k8s authenticator. This authenticator can establish a secure mTLS connection compliant with the SPIFFE framework, as described in the following diagram (click here for more details).\n","permalink":"http://localhost:1313/posts/cyberark-conjur-authenticators-integrations/","tags":["conjur","authenticators","spiffe","integrations"],"title":"CyberArk Conjur , authenticators and integrations"},{"content":"As I wrote in my last post, CyberArk Conjur is an enterprise secrets manager. , CyberArk Conjur is an enterprise secrets manager.\nIn this post, I’ll provide an architecture overview along with the main system requirements.\nConjur is currently available in two versions: Enterprise and open source (known as OSS).\nA “cloud” version will be available soon, offered as a SaaS solution.\nThis post focuses on the Enterprise version, which is similar but not identical to the OSS version.\nArchitecture Conjur is distributed as a Docker image, making deployment and configuration fast and secure.\nThe main services included in the appliance image are:\nnginx: Provides access to the administrative GUI and the API set for interacting with secrets. PostgreSQL database: Two databases, one for configurations and secrets, and one for audit logs. Conjur appliance: The core product. syslog-ng: Used to collect audit and access logs. The smallest common configuration for Conjur Enterprise is a three-node cluster with auto-failover, as shown in the following diagram:\nThe cluster architecture follows an active-passive model, with high availability guaranteed by a load balancer placed in front of the cluster. This load balancer switches the node accessed by applications in case of a failure.\nWithin the cluster, one node acts as the “leader node,” handling all read/write operations and providing the API for applications to interact with secrets.\nThe secondary nodes are called “standbys” and can be either synchronous or asynchronous, depending on the PostgreSQL replication setup.\nThese nodes are inactive and do not provide API services.\nIf the leader node fails, after a configurable period, the standbys will elect a new leader using etcd and the Raft consensus algorithm.\nIf auto-failover is not configured, manual promotion is required.\nIt is also possible to configure a primary site with auto-failover and a secondary site with asynchronous standbys (without auto-failover), ready to be promoted manually.\nThe final component of the architecture is the “follower,” a read-only replica of the leader. Followers allow secrets to be read at scale and are horizontally scalable components typically configured behind a load balancer to handle all types of read requests, including authentication, permission checks, and secret fetches.\nFollowers are usually installed on a Kubernetes cluster to serve applications with low latency.\nThe architecture diagram with followers could be expanded as shown below:\nSystem Requirements Production environment:\n4 cores 8 GB RAM 50 GB hard drive Test environment:\n2 cores 4 GB RAM 20 GB hard drive Supported container runtimes:\nDocker 1.13 or later Mirantis Container Runtime (MRC) 19.x, 20.10 on RHEL 8.x Kubernetes and OpenShift (only for the follower) Podman 3.3 and 3.4 The host server should run an operating system supported by the container runtime (the most popular are RHEL Server, RHEL-based, or Ubuntu Server LTS). To read more detail or updated versions please refer to this page.\nIf the customer environment also includes a CyberArk Vault server that needs to be synchronized with Conjur, the following are the requirements for a CyberArk Vault Synchronizer server:\n4 cores 8 GB RAM Windows Server 2012 R2 or later ","permalink":"http://localhost:1313/posts/cyberark-conjur-architecture-system-requirements/","tags":["conjur","cyberark","secrets manager"],"title":"CyberArk Conjur: A Quick Overview of Architecture and System Requirements"},{"content":"Security is always a complex topic to address, as an error or omission in processes can lead to serious economic or reputational damage for a company.\nWhen we talk about “secrets,” consider the following examples:\nUsernames Database passwords SSL certificates and keys SSH keys Cloud credentials Simply reading through this list helps to explain why this topic needs to be considered and handled carefully.\nSome common bad practices or risks include:\nHardcoding secrets in code Data breaches Password leaks Secrets pushed to public repositories With practices like lateral movement, just one compromised secret can be enough to compromise an entire environment. To help prevent these risks, there are tools known as “enterprise secrets managers.” I’d like to start a series of posts on this blog about CyberArk Conjur.\nConjur allows you to avoid direct use of secrets by leveraging a set of REST APIs, making it a programmable tool that can be accessed via URL or open source utilities.\nSecurity is enforced through security policies without slowing down the developers involved.\nCorporate security can be further improved with the use of rotators, which programmatically change secret values.\nIf other CyberArk software like PAS Vault is already in use, Conjur can be integrated using the Synchroniser component,\nproviding the same level of security for cloud-native infrastructure.\nConjur is available in two versions: enterprise and open source, each with distinct features.\nIn upcoming posts, I will explain details about the architecture, secrets management, and product news related to CyberArk Conjur.\n","permalink":"http://localhost:1313/posts/why-you-need-kubernetes-secrets-manager/","tags":["conjur","introduction","secrets manager"],"title":"CyberArk Conjur - why you (probably) need an enterprise secrets manager"},{"content":"Hello there! How are you?\nI’m really good! As you may have seen on my social media, starting from the 16th of May, I’ve begun a new position as Senior DevSecOps at SIGHUP.\nI’m really excited about this new opportunity, and I’m writing this post because it will also have an effect on this blog’s focus.\nThe topics will shift from previous subjects to cloud-native infrastructure security, starting with tools like CyberArk Conjur. The previous content on this blog will remain here forever. I believe it could be helpful for some time, and I also want to honor my HCL Ambassador role.\nI’d also love to add that my current role as organizer of the LetsConnect user group will remain unchanged.\nI hope to see you all again at our next event!\n","permalink":"http://localhost:1313/posts/new-job-devsecops-teamleader/","tags":["cloudnative","newjob","devsecops","security"],"title":"I've started a new journey as DevSecOps Team Leader"},{"content":"","permalink":"http://localhost:1313/search/","tags":null,"title":"Search"},{"content":"Hello, I’m Matteo Bisi.\nI’m a DevSecOps Team Leader currently living in Galway, Ireland, but originally from Italy.\nWith a passion for both technology and teamwork, I lead my team in building and securing cloud-native infrastructures using both open source and enterprise tools.\nMy journey has taken me across different roles, giving me a unique perspective on how diverse teams collaborate and innovate.\nI’m particularly interested in automating security practices, managing secrets at scale, and empowering development teams to deliver secure software efficiently.\nOutside of work, I enjoy exploring the beautiful Irish countryside, planning my next family trip, and cooking some Italian recipes.\nThrough this blog, I hope to share insights, best practices, and lessons learned from my experiences leading DevSecOps teams.\nYou can find more information about my CV on my LinkedIn profile.\nMy preavious blogs about Collaboration solutions are available here:\nitalian blog english blog ","permalink":"http://localhost:1313/aboutme/","tags":["biography"],"title":"About Me - Matteo Bisi"},{"content":"During the past few weeks, I have described what a secrets manager is and provided an overview of the architecture and system requirements of CyberArk Conjur.\nA secrets manager can’t do its job if it can’t communicate with those who need to request secrets, and that’s where Conjur’s magic comes in!\nThe “authenticators” are responsible for the authentication process in Conjur and are specialized to do this in the most secure way, depending on the service.\nHere is the list of authenticators currently supported:\nAuthenticator Description authn Defines the Conjur default authenticator. Authentication for both users and hosts is based on an ID and API key. authn-oidc Leverages the identity layer provided by OIDC to allow applications to authenticate with Conjur and retrieve secrets needed for connecting to services such as a database. [authn-iam(https://docs.cyberark.com/Product-Doc/OnlineHelp/AAM-DAP/Latest/en/Content/Operations/Services/AWS_IAM_Authenticator.htm)] Enables an AWS resource to use its AWS IAM role to authenticate with Conjur. authn-azure Enables an Azure resource to authenticate with Conjur authn-jwt Enables an application to authenticate to Conjur using a JWT from a JWT Provider. authn-gcp Enables a Google Cloud Platform resource to authenticate with Conjur authn-k8s Authenticates hosts that are Kubernetes resources, such as a Kubernetes namespace, deployment, stateful set, and others. Authentication is certificate-based using a mutual TLS connection. authn-ldap Authenticates users based on an LDAP directory. By default, after the initial setup, authn is the only authenticator enabled, and it is responsible for Conjur access using a username or API key (randomly generated between 51 and 56 characters).\nWhen integrations are needed, for example with a Kubernetes cluster, you need to activate and configure the authn-k8s authenticator. This authenticator can establish a secure mTLS connection compliant with the SPIFFE framework, as described in the following diagram (click here for more details).\n","permalink":"http://localhost:1313/posts/cyberark-conjur-authenticators-integrations/","tags":["conjur","authenticators","spiffe","integrations"],"title":"CyberArk Conjur , authenticators and integrations"},{"content":"As I wrote in my last post, CyberArk Conjur is an enterprise secrets manager. , CyberArk Conjur is an enterprise secrets manager.\nIn this post, I’ll provide an architecture overview along with the main system requirements.\nConjur is currently available in two versions: Enterprise and open source (known as OSS).\nA “cloud” version will be available soon, offered as a SaaS solution.\nThis post focuses on the Enterprise version, which is similar but not identical to the OSS version.\nArchitecture Conjur is distributed as a Docker image, making deployment and configuration fast and secure.\nThe main services included in the appliance image are:\nnginx: Provides access to the administrative GUI and the API set for interacting with secrets. PostgreSQL database: Two databases, one for configurations and secrets, and one for audit logs. Conjur appliance: The core product. syslog-ng: Used to collect audit and access logs. The smallest common configuration for Conjur Enterprise is a three-node cluster with auto-failover, as shown in the following diagram:\nThe cluster architecture follows an active-passive model, with high availability guaranteed by a load balancer placed in front of the cluster. This load balancer switches the node accessed by applications in case of a failure.\nWithin the cluster, one node acts as the “leader node,” handling all read/write operations and providing the API for applications to interact with secrets.\nThe secondary nodes are called “standbys” and can be either synchronous or asynchronous, depending on the PostgreSQL replication setup.\nThese nodes are inactive and do not provide API services.\nIf the leader node fails, after a configurable period, the standbys will elect a new leader using etcd and the Raft consensus algorithm.\nIf auto-failover is not configured, manual promotion is required.\nIt is also possible to configure a primary site with auto-failover and a secondary site with asynchronous standbys (without auto-failover), ready to be promoted manually.\nThe final component of the architecture is the “follower,” a read-only replica of the leader. Followers allow secrets to be read at scale and are horizontally scalable components typically configured behind a load balancer to handle all types of read requests, including authentication, permission checks, and secret fetches.\nFollowers are usually installed on a Kubernetes cluster to serve applications with low latency.\nThe architecture diagram with followers could be expanded as shown below:\nSystem Requirements Production environment:\n4 cores 8 GB RAM 50 GB hard drive Test environment:\n2 cores 4 GB RAM 20 GB hard drive Supported container runtimes:\nDocker 1.13 or later Mirantis Container Runtime (MRC) 19.x, 20.10 on RHEL 8.x Kubernetes and OpenShift (only for the follower) Podman 3.3 and 3.4 The host server should run an operating system supported by the container runtime (the most popular are RHEL Server, RHEL-based, or Ubuntu Server LTS). To read more detail or updated versions please refer to this page.\nIf the customer environment also includes a CyberArk Vault server that needs to be synchronized with Conjur, the following are the requirements for a CyberArk Vault Synchronizer server:\n4 cores 8 GB RAM Windows Server 2012 R2 or later ","permalink":"http://localhost:1313/posts/cyberark-conjur-architecture-system-requirements/","tags":["conjur","cyberark","secrets manager"],"title":"CyberArk Conjur: A Quick Overview of Architecture and System Requirements"},{"content":"Security is always a complex topic to address, as an error or omission in processes can lead to serious economic or reputational damage for a company.\nWhen we talk about “secrets,” consider the following examples:\nUsernames Database passwords SSL certificates and keys SSH keys Cloud credentials Simply reading through this list helps to explain why this topic needs to be considered and handled carefully.\nSome common bad practices or risks include:\nHardcoding secrets in code Data breaches Password leaks Secrets pushed to public repositories With practices like lateral movement, just one compromised secret can be enough to compromise an entire environment. To help prevent these risks, there are tools known as “enterprise secrets managers.” I’d like to start a series of posts on this blog about CyberArk Conjur.\nConjur allows you to avoid direct use of secrets by leveraging a set of REST APIs, making it a programmable tool that can be accessed via URL or open source utilities.\nSecurity is enforced through security policies without slowing down the developers involved.\nCorporate security can be further improved with the use of rotators, which programmatically change secret values.\nIf other CyberArk software like PAS Vault is already in use, Conjur can be integrated using the Synchroniser component,\nproviding the same level of security for cloud-native infrastructure.\nConjur is available in two versions: enterprise and open source, each with distinct features.\nIn upcoming posts, I will explain details about the architecture, secrets management, and product news related to CyberArk Conjur.\n","permalink":"http://localhost:1313/posts/why-you-need-kubernetes-secrets-manager/","tags":["conjur","introduction","secrets manager"],"title":"CyberArk Conjur - why you (probably) need an enterprise secrets manager"},{"content":"Hello there! How are you?\nI’m really good! As you may have seen on my social media, starting from the 16th of May, I’ve begun a new position as Senior DevSecOps at SIGHUP.\nI’m really excited about this new opportunity, and I’m writing this post because it will also have an effect on this blog’s focus.\nThe topics will shift from previous subjects to cloud-native infrastructure security, starting with tools like CyberArk Conjur. The previous content on this blog will remain here forever. I believe it could be helpful for some time, and I also want to honor my HCL Ambassador role.\nI’d also love to add that my current role as organizer of the LetsConnect user group will remain unchanged.\nI hope to see you all again at our next event!\n","permalink":"http://localhost:1313/posts/new-job-devsecops-teamleader/","tags":["cloudnative","newjob","devsecops","security"],"title":"I've started a new journey as DevSecOps Team Leader"},{"content":"","permalink":"http://localhost:1313/search/","tags":null,"title":"Search"},{"content":"Hello, I’m Matteo Bisi.\nI’m a DevSecOps Team Leader currently living in Galway, Ireland, but originally from Italy.\nWith a passion for both technology and teamwork, I lead my team in building and securing cloud-native infrastructures using both open source and enterprise tools.\nMy journey has taken me across different roles, giving me a unique perspective on how diverse teams collaborate and innovate.\nI’m particularly interested in automating security practices, managing secrets at scale, and empowering development teams to deliver secure software efficiently.\nOutside of work, I enjoy exploring the beautiful Irish countryside, planning my next family trip, and cooking some Italian recipes.\nThrough this blog, I hope to share insights, best practices, and lessons learned from my experiences leading DevSecOps teams.\nYou can find more information about my CV on my LinkedIn profile.\nMy preavious blogs about Collaboration solutions are available here:\nitalian blog english blog ","permalink":"http://localhost:1313/aboutme/","tags":["biography"],"title":"About Me - Matteo Bisi"},{"content":"During the past few weeks, I have described what a secrets manager is and provided an overview of the architecture and system requirements of CyberArk Conjur.\nA secrets manager can’t do its job if it can’t communicate with those who need to request secrets, and that’s where Conjur’s magic comes in!\nThe “authenticators” are responsible for the authentication process in Conjur and are specialized to do this in the most secure way, depending on the service.\nHere is the list of authenticators currently supported:\nAuthenticator Description authn Defines the Conjur default authenticator. Authentication for both users and hosts is based on an ID and API key. authn-oidc Leverages the identity layer provided by OIDC to allow applications to authenticate with Conjur and retrieve secrets needed for connecting to services such as a database. [authn-iam(https://docs.cyberark.com/Product-Doc/OnlineHelp/AAM-DAP/Latest/en/Content/Operations/Services/AWS_IAM_Authenticator.htm)] Enables an AWS resource to use its AWS IAM role to authenticate with Conjur. authn-azure Enables an Azure resource to authenticate with Conjur authn-jwt Enables an application to authenticate to Conjur using a JWT from a JWT Provider. authn-gcp Enables a Google Cloud Platform resource to authenticate with Conjur authn-k8s Authenticates hosts that are Kubernetes resources, such as a Kubernetes namespace, deployment, stateful set, and others. Authentication is certificate-based using a mutual TLS connection. authn-ldap Authenticates users based on an LDAP directory. By default, after the initial setup, authn is the only authenticator enabled, and it is responsible for Conjur access using a username or API key (randomly generated between 51 and 56 characters).\nWhen integrations are needed, for example with a Kubernetes cluster, you need to activate and configure the authn-k8s authenticator. This authenticator can establish a secure mTLS connection compliant with the SPIFFE framework, as described in the following diagram (click here for more details).\nIf you need integrations with cloud identities that support JWT authentication, such as Google Apigee, you will enable the authn-jwt authenticator, which will perform the integrations as shown below:\n","permalink":"http://localhost:1313/posts/cyberark-conjur-authenticators-integrations/","tags":["conjur","authenticators","spiffe","integrations"],"title":"CyberArk Conjur , authenticators and integrations"},{"content":"As I wrote in my last post, CyberArk Conjur is an enterprise secrets manager. , CyberArk Conjur is an enterprise secrets manager.\nIn this post, I’ll provide an architecture overview along with the main system requirements.\nConjur is currently available in two versions: Enterprise and open source (known as OSS).\nA “cloud” version will be available soon, offered as a SaaS solution.\nThis post focuses on the Enterprise version, which is similar but not identical to the OSS version.\nArchitecture Conjur is distributed as a Docker image, making deployment and configuration fast and secure.\nThe main services included in the appliance image are:\nnginx: Provides access to the administrative GUI and the API set for interacting with secrets. PostgreSQL database: Two databases, one for configurations and secrets, and one for audit logs. Conjur appliance: The core product. syslog-ng: Used to collect audit and access logs. The smallest common configuration for Conjur Enterprise is a three-node cluster with auto-failover, as shown in the following diagram:\nThe cluster architecture follows an active-passive model, with high availability guaranteed by a load balancer placed in front of the cluster. This load balancer switches the node accessed by applications in case of a failure.\nWithin the cluster, one node acts as the “leader node,” handling all read/write operations and providing the API for applications to interact with secrets.\nThe secondary nodes are called “standbys” and can be either synchronous or asynchronous, depending on the PostgreSQL replication setup.\nThese nodes are inactive and do not provide API services.\nIf the leader node fails, after a configurable period, the standbys will elect a new leader using etcd and the Raft consensus algorithm.\nIf auto-failover is not configured, manual promotion is required.\nIt is also possible to configure a primary site with auto-failover and a secondary site with asynchronous standbys (without auto-failover), ready to be promoted manually.\nThe final component of the architecture is the “follower,” a read-only replica of the leader. Followers allow secrets to be read at scale and are horizontally scalable components typically configured behind a load balancer to handle all types of read requests, including authentication, permission checks, and secret fetches.\nFollowers are usually installed on a Kubernetes cluster to serve applications with low latency.\nThe architecture diagram with followers could be expanded as shown below:\nSystem Requirements Production environment:\n4 cores 8 GB RAM 50 GB hard drive Test environment:\n2 cores 4 GB RAM 20 GB hard drive Supported container runtimes:\nDocker 1.13 or later Mirantis Container Runtime (MRC) 19.x, 20.10 on RHEL 8.x Kubernetes and OpenShift (only for the follower) Podman 3.3 and 3.4 The host server should run an operating system supported by the container runtime (the most popular are RHEL Server, RHEL-based, or Ubuntu Server LTS). To read more detail or updated versions please refer to this page.\nIf the customer environment also includes a CyberArk Vault server that needs to be synchronized with Conjur, the following are the requirements for a CyberArk Vault Synchronizer server:\n4 cores 8 GB RAM Windows Server 2012 R2 or later ","permalink":"http://localhost:1313/posts/cyberark-conjur-architecture-system-requirements/","tags":["conjur","cyberark","secrets manager"],"title":"CyberArk Conjur: A Quick Overview of Architecture and System Requirements"},{"content":"Security is always a complex topic to address, as an error or omission in processes can lead to serious economic or reputational damage for a company.\nWhen we talk about “secrets,” consider the following examples:\nUsernames Database passwords SSL certificates and keys SSH keys Cloud credentials Simply reading through this list helps to explain why this topic needs to be considered and handled carefully.\nSome common bad practices or risks include:\nHardcoding secrets in code Data breaches Password leaks Secrets pushed to public repositories With practices like lateral movement, just one compromised secret can be enough to compromise an entire environment. To help prevent these risks, there are tools known as “enterprise secrets managers.” I’d like to start a series of posts on this blog about CyberArk Conjur.\nConjur allows you to avoid direct use of secrets by leveraging a set of REST APIs, making it a programmable tool that can be accessed via URL or open source utilities.\nSecurity is enforced through security policies without slowing down the developers involved.\nCorporate security can be further improved with the use of rotators, which programmatically change secret values.\nIf other CyberArk software like PAS Vault is already in use, Conjur can be integrated using the Synchroniser component,\nproviding the same level of security for cloud-native infrastructure.\nConjur is available in two versions: enterprise and open source, each with distinct features.\nIn upcoming posts, I will explain details about the architecture, secrets management, and product news related to CyberArk Conjur.\n","permalink":"http://localhost:1313/posts/why-you-need-kubernetes-secrets-manager/","tags":["conjur","introduction","secrets manager"],"title":"CyberArk Conjur - why you (probably) need an enterprise secrets manager"},{"content":"Hello there! How are you?\nI’m really good! As you may have seen on my social media, starting from the 16th of May, I’ve begun a new position as Senior DevSecOps at SIGHUP.\nI’m really excited about this new opportunity, and I’m writing this post because it will also have an effect on this blog’s focus.\nThe topics will shift from previous subjects to cloud-native infrastructure security, starting with tools like CyberArk Conjur. The previous content on this blog will remain here forever. I believe it could be helpful for some time, and I also want to honor my HCL Ambassador role.\nI’d also love to add that my current role as organizer of the LetsConnect user group will remain unchanged.\nI hope to see you all again at our next event!\n","permalink":"http://localhost:1313/posts/new-job-devsecops-teamleader/","tags":["cloudnative","newjob","devsecops","security"],"title":"I've started a new journey as DevSecOps Team Leader"},{"content":"","permalink":"http://localhost:1313/search/","tags":null,"title":"Search"},{"content":"Hello, I’m Matteo Bisi.\nI’m a DevSecOps Team Leader currently living in Galway, Ireland, but originally from Italy.\nWith a passion for both technology and teamwork, I lead my team in building and securing cloud-native infrastructures using both open source and enterprise tools.\nMy journey has taken me across different roles, giving me a unique perspective on how diverse teams collaborate and innovate.\nI’m particularly interested in automating security practices, managing secrets at scale, and empowering development teams to deliver secure software efficiently.\nOutside of work, I enjoy exploring the beautiful Irish countryside, planning my next family trip, and cooking some Italian recipes.\nThrough this blog, I hope to share insights, best practices, and lessons learned from my experiences leading DevSecOps teams.\nYou can find more information about my CV on my LinkedIn profile.\nMy preavious blogs about Collaboration solutions are available here:\nitalian blog english blog ","permalink":"http://localhost:1313/aboutme/","tags":["biography"],"title":"About Me - Matteo Bisi"},{"content":"During the past few weeks, I have described what a secrets manager is and provided an overview of the architecture and system requirements of CyberArk Conjur.\nA secrets manager can’t do its job if it can’t communicate with those who need to request secrets, and that’s where Conjur’s magic comes in!\nThe “authenticators” are responsible for the authentication process in Conjur and are specialized to do this in the most secure way, depending on the service.\nHere is the list of authenticators currently supported:\nAuthenticator Description authn Defines the Conjur default authenticator. Authentication for both users and hosts is based on an ID and API key. authn-oidc Leverages the identity layer provided by OIDC to allow applications to authenticate with Conjur and retrieve secrets needed for connecting to services such as a database. [authn-iam(https://docs.cyberark.com/Product-Doc/OnlineHelp/AAM-DAP/Latest/en/Content/Operations/Services/AWS_IAM_Authenticator.htm)] Enables an AWS resource to use its AWS IAM role to authenticate with Conjur. authn-azure Enables an Azure resource to authenticate with Conjur authn-jwt Enables an application to authenticate to Conjur using a JWT from a JWT Provider. authn-gcp Enables a Google Cloud Platform resource to authenticate with Conjur authn-k8s Authenticates hosts that are Kubernetes resources, such as a Kubernetes namespace, deployment, stateful set, and others. Authentication is certificate-based using a mutual TLS connection. authn-ldap Authenticates users based on an LDAP directory. By default, after the initial setup, authn is the only authenticator enabled, and it is responsible for Conjur access using a username or API key (randomly generated between 51 and 56 characters).\nWhen integrations are needed, for example with a Kubernetes cluster, you need to activate and configure the authn-k8s authenticator. This authenticator can establish a secure mTLS connection compliant with the SPIFFE framework, as described in the following diagram (click here for more details).\nIf you need integrations with cloud identities that support JWT authentication, such as Google Apigee, you will enable the authn-jwt authenticator, which will perform the integrations as shown below:\nThese were just two examples among the many possible secure integrations enabled by the authenticators. The following is a more complete list:\nKubernetes (local or cloud) API gateway Jenkins Ansible Puppet Terraform Cloud services If the scenario described sounds interesting for your needs, Conjur could definitely be the right choice. Contact your sales representative at CyberArk or your preferred CyberArk business partner.\n","permalink":"http://localhost:1313/posts/cyberark-conjur-authenticators-integrations/","tags":["conjur","authenticators","spiffe","integrations"],"title":"CyberArk Conjur , authenticators and integrations"},{"content":"As I wrote in my last post, CyberArk Conjur is an enterprise secrets manager. , CyberArk Conjur is an enterprise secrets manager.\nIn this post, I’ll provide an architecture overview along with the main system requirements.\nConjur is currently available in two versions: Enterprise and open source (known as OSS).\nA “cloud” version will be available soon, offered as a SaaS solution.\nThis post focuses on the Enterprise version, which is similar but not identical to the OSS version.\nArchitecture Conjur is distributed as a Docker image, making deployment and configuration fast and secure.\nThe main services included in the appliance image are:\nnginx: Provides access to the administrative GUI and the API set for interacting with secrets. PostgreSQL database: Two databases, one for configurations and secrets, and one for audit logs. Conjur appliance: The core product. syslog-ng: Used to collect audit and access logs. The smallest common configuration for Conjur Enterprise is a three-node cluster with auto-failover, as shown in the following diagram:\nThe cluster architecture follows an active-passive model, with high availability guaranteed by a load balancer placed in front of the cluster. This load balancer switches the node accessed by applications in case of a failure.\nWithin the cluster, one node acts as the “leader node,” handling all read/write operations and providing the API for applications to interact with secrets.\nThe secondary nodes are called “standbys” and can be either synchronous or asynchronous, depending on the PostgreSQL replication setup.\nThese nodes are inactive and do not provide API services.\nIf the leader node fails, after a configurable period, the standbys will elect a new leader using etcd and the Raft consensus algorithm.\nIf auto-failover is not configured, manual promotion is required.\nIt is also possible to configure a primary site with auto-failover and a secondary site with asynchronous standbys (without auto-failover), ready to be promoted manually.\nThe final component of the architecture is the “follower,” a read-only replica of the leader. Followers allow secrets to be read at scale and are horizontally scalable components typically configured behind a load balancer to handle all types of read requests, including authentication, permission checks, and secret fetches.\nFollowers are usually installed on a Kubernetes cluster to serve applications with low latency.\nThe architecture diagram with followers could be expanded as shown below:\nSystem Requirements Production environment:\n4 cores 8 GB RAM 50 GB hard drive Test environment:\n2 cores 4 GB RAM 20 GB hard drive Supported container runtimes:\nDocker 1.13 or later Mirantis Container Runtime (MRC) 19.x, 20.10 on RHEL 8.x Kubernetes and OpenShift (only for the follower) Podman 3.3 and 3.4 The host server should run an operating system supported by the container runtime (the most popular are RHEL Server, RHEL-based, or Ubuntu Server LTS). To read more detail or updated versions please refer to this page.\nIf the customer environment also includes a CyberArk Vault server that needs to be synchronized with Conjur, the following are the requirements for a CyberArk Vault Synchronizer server:\n4 cores 8 GB RAM Windows Server 2012 R2 or later ","permalink":"http://localhost:1313/posts/cyberark-conjur-architecture-system-requirements/","tags":["conjur","cyberark","secrets manager"],"title":"CyberArk Conjur: A Quick Overview of Architecture and System Requirements"},{"content":"Security is always a complex topic to address, as an error or omission in processes can lead to serious economic or reputational damage for a company.\nWhen we talk about “secrets,” consider the following examples:\nUsernames Database passwords SSL certificates and keys SSH keys Cloud credentials Simply reading through this list helps to explain why this topic needs to be considered and handled carefully.\nSome common bad practices or risks include:\nHardcoding secrets in code Data breaches Password leaks Secrets pushed to public repositories With practices like lateral movement, just one compromised secret can be enough to compromise an entire environment. To help prevent these risks, there are tools known as “enterprise secrets managers.” I’d like to start a series of posts on this blog about CyberArk Conjur.\nConjur allows you to avoid direct use of secrets by leveraging a set of REST APIs, making it a programmable tool that can be accessed via URL or open source utilities.\nSecurity is enforced through security policies without slowing down the developers involved.\nCorporate security can be further improved with the use of rotators, which programmatically change secret values.\nIf other CyberArk software like PAS Vault is already in use, Conjur can be integrated using the Synchroniser component,\nproviding the same level of security for cloud-native infrastructure.\nConjur is available in two versions: enterprise and open source, each with distinct features.\nIn upcoming posts, I will explain details about the architecture, secrets management, and product news related to CyberArk Conjur.\n","permalink":"http://localhost:1313/posts/why-you-need-kubernetes-secrets-manager/","tags":["conjur","introduction","secrets manager"],"title":"CyberArk Conjur - why you (probably) need an enterprise secrets manager"},{"content":"Hello there! How are you?\nI’m really good! As you may have seen on my social media, starting from the 16th of May, I’ve begun a new position as Senior DevSecOps at SIGHUP.\nI’m really excited about this new opportunity, and I’m writing this post because it will also have an effect on this blog’s focus.\nThe topics will shift from previous subjects to cloud-native infrastructure security, starting with tools like CyberArk Conjur. The previous content on this blog will remain here forever. I believe it could be helpful for some time, and I also want to honor my HCL Ambassador role.\nI’d also love to add that my current role as organizer of the LetsConnect user group will remain unchanged.\nI hope to see you all again at our next event!\n","permalink":"http://localhost:1313/posts/new-job-devsecops-teamleader/","tags":["cloudnative","newjob","devsecops","security"],"title":"I've started a new journey as DevSecOps Team Leader"},{"content":"","permalink":"http://localhost:1313/search/","tags":null,"title":"Search"},{"content":"Hello, I’m Matteo Bisi.\nI’m a DevSecOps Team Leader currently living in Galway, Ireland, but originally from Italy.\nWith a passion for both technology and teamwork, I lead my team in building and securing cloud-native infrastructures using both open source and enterprise tools.\nMy journey has taken me across different roles, giving me a unique perspective on how diverse teams collaborate and innovate.\nI’m particularly interested in automating security practices, managing secrets at scale, and empowering development teams to deliver secure software efficiently.\nOutside of work, I enjoy exploring the beautiful Irish countryside, planning my next family trip, and cooking some Italian recipes.\nThrough this blog, I hope to share insights, best practices, and lessons learned from my experiences leading DevSecOps teams.\nYou can find more information about my CV on my LinkedIn profile.\nMy preavious blogs about Collaboration solutions are available here:\nitalian blog english blog ","permalink":"http://localhost:1313/aboutme/","tags":["biography"],"title":"About Me - Matteo Bisi"},{"content":"During the past few weeks, I have described what a secrets manager is and provided an overview of the architecture and system requirements of CyberArk Conjur.\nA secrets manager can’t do its job if it can’t communicate with those who need to request secrets, and that’s where Conjur’s magic comes in!\nThe “authenticators” are responsible for the authentication process in Conjur and are specialized to do this in the most secure way, depending on the service.\nHere is the list of authenticators currently supported:\nAuthenticator Description authn Defines the Conjur default authenticator. Authentication for both users and hosts is based on an ID and API key. authn-oidc Leverages the identity layer provided by OIDC to allow applications to authenticate with Conjur and retrieve secrets needed for connecting to services such as a database. [authn-iam(https://docs.cyberark.com/Product-Doc/OnlineHelp/AAM-DAP/Latest/en/Content/Operations/Services/AWS_IAM_Authenticator.htm)] Enables an AWS resource to use its AWS IAM role to authenticate with Conjur. authn-azure Enables an Azure resource to authenticate with Conjur authn-jwt Enables an application to authenticate to Conjur using a JWT from a JWT Provider. authn-gcp Enables a Google Cloud Platform resource to authenticate with Conjur authn-k8s Authenticates hosts that are Kubernetes resources, such as a Kubernetes namespace, deployment, stateful set, and others. Authentication is certificate-based using a mutual TLS connection. authn-ldap Authenticates users based on an LDAP directory. By default, after the initial setup, authn is the only authenticator enabled, and it is responsible for Conjur access using a username or API key (randomly generated between 51 and 56 characters).\nWhen integrations are needed, for example with a Kubernetes cluster, you need to activate and configure the authn-k8s authenticator. This authenticator can establish a secure mTLS connection compliant with the SPIFFE framework, as described in the following diagram (click here for more details).\nIf you need integrations with cloud identities that support JWT authentication, such as Google Apigee, you will enable the authn-jwt authenticator, which will perform the integrations as shown below:\nThese were just two examples among the many possible secure integrations enabled by the authenticators. The following is a more complete list:\nKubernetes (local or cloud) API gateway Jenkins Ansible Puppet Terraform Cloud services If the scenario described sounds interesting for your needs, Conjur could definitely be the right choice. Contact your sales representative at CyberArk or your preferred CyberArk business partner.\n","permalink":"http://localhost:1313/posts/cyberark-conjur-authenticators-integrations/","tags":["conjur","authenticators","spiffe","integrations"],"title":"CyberArk Conjur , authenticators and integrations"},{"content":"As I wrote in my last post, CyberArk Conjur is an enterprise secrets manager. , CyberArk Conjur is an enterprise secrets manager.\nIn this post, I’ll provide an architecture overview along with the main system requirements.\nConjur is currently available in two versions: Enterprise and open source (known as OSS).\nA “cloud” version will be available soon, offered as a SaaS solution.\nThis post focuses on the Enterprise version, which is similar but not identical to the OSS version.\nArchitecture Conjur is distributed as a Docker image, making deployment and configuration fast and secure.\nThe main services included in the appliance image are:\nnginx: Provides access to the administrative GUI and the API set for interacting with secrets. PostgreSQL database: Two databases, one for configurations and secrets, and one for audit logs. Conjur appliance: The core product. syslog-ng: Used to collect audit and access logs. The smallest common configuration for Conjur Enterprise is a three-node cluster with auto-failover, as shown in the following diagram:\nThe cluster architecture follows an active-passive model, with high availability guaranteed by a load balancer placed in front of the cluster. This load balancer switches the node accessed by applications in case of a failure.\nWithin the cluster, one node acts as the “leader node,” handling all read/write operations and providing the API for applications to interact with secrets.\nThe secondary nodes are called “standbys” and can be either synchronous or asynchronous, depending on the PostgreSQL replication setup.\nThese nodes are inactive and do not provide API services.\nIf the leader node fails, after a configurable period, the standbys will elect a new leader using etcd and the Raft consensus algorithm.\nIf auto-failover is not configured, manual promotion is required.\nIt is also possible to configure a primary site with auto-failover and a secondary site with asynchronous standbys (without auto-failover), ready to be promoted manually.\nThe final component of the architecture is the “follower,” a read-only replica of the leader. Followers allow secrets to be read at scale and are horizontally scalable components typically configured behind a load balancer to handle all types of read requests, including authentication, permission checks, and secret fetches.\nFollowers are usually installed on a Kubernetes cluster to serve applications with low latency.\nThe architecture diagram with followers could be expanded as shown below:\nSystem Requirements Production environment:\n4 cores 8 GB RAM 50 GB hard drive Test environment:\n2 cores 4 GB RAM 20 GB hard drive Supported container runtimes:\nDocker 1.13 or later Mirantis Container Runtime (MRC) 19.x, 20.10 on RHEL 8.x Kubernetes and OpenShift (only for the follower) Podman 3.3 and 3.4 The host server should run an operating system supported by the container runtime (the most popular are RHEL Server, RHEL-based, or Ubuntu Server LTS). To read more detail or updated versions please refer to this page.\nIf the customer environment also includes a CyberArk Vault server that needs to be synchronized with Conjur, the following are the requirements for a CyberArk Vault Synchronizer server:\n4 cores 8 GB RAM Windows Server 2012 R2 or later ","permalink":"http://localhost:1313/posts/cyberark-conjur-architecture-system-requirements/","tags":["conjur","cyberark","secrets manager"],"title":"CyberArk Conjur: A Quick Overview of Architecture and System Requirements"},{"content":"Security is always a complex topic to address, as an error or omission in processes can lead to serious economic or reputational damage for a company.\nWhen we talk about “secrets,” consider the following examples:\nUsernames Database passwords SSL certificates and keys SSH keys Cloud credentials Simply reading through this list helps to explain why this topic needs to be considered and handled carefully.\nSome common bad practices or risks include:\nHardcoding secrets in code Data breaches Password leaks Secrets pushed to public repositories With practices like lateral movement, just one compromised secret can be enough to compromise an entire environment. To help prevent these risks, there are tools known as “enterprise secrets managers.” I’d like to start a series of posts on this blog about CyberArk Conjur.\nConjur allows you to avoid direct use of secrets by leveraging a set of REST APIs, making it a programmable tool that can be accessed via URL or open source utilities.\nSecurity is enforced through security policies without slowing down the developers involved.\nCorporate security can be further improved with the use of rotators, which programmatically change secret values.\nIf other CyberArk software like PAS Vault is already in use, Conjur can be integrated using the Synchroniser component,\nproviding the same level of security for cloud-native infrastructure.\nConjur is available in two versions: enterprise and open source, each with distinct features.\nIn upcoming posts, I will explain details about the architecture, secrets management, and product news related to CyberArk Conjur.\n","permalink":"http://localhost:1313/posts/why-you-need-kubernetes-secrets-manager/","tags":["conjur","introduction","secrets manager"],"title":"CyberArk Conjur - why you (probably) need an enterprise secrets manager"},{"content":"Hello there! How are you?\nI’m really good! As you may have seen on my social media, starting from the 16th of May, I’ve begun a new position as Senior DevSecOps at SIGHUP.\nI’m really excited about this new opportunity, and I’m writing this post because it will also have an effect on this blog’s focus.\nThe topics will shift from previous subjects to cloud-native infrastructure security, starting with tools like CyberArk Conjur. The previous content on this blog will remain here forever. I believe it could be helpful for some time, and I also want to honor my HCL Ambassador role.\nI’d also love to add that my current role as organizer of the LetsConnect user group will remain unchanged.\nI hope to see you all again at our next event!\n","permalink":"http://localhost:1313/posts/new-job-devsecops-teamleader/","tags":["cloudnative","newjob","devsecops","security"],"title":"I've started a new journey as DevSecOps Team Leader"},{"content":"","permalink":"http://localhost:1313/search/","tags":null,"title":"Search"},{"content":"Hello, I’m Matteo Bisi.\nI’m a DevSecOps Team Leader currently living in Galway, Ireland, but originally from Italy.\nWith a passion for both technology and teamwork, I lead my team in building and securing cloud-native infrastructures using both open source and enterprise tools.\nMy journey has taken me across different roles, giving me a unique perspective on how diverse teams collaborate and innovate.\nI’m particularly interested in automating security practices, managing secrets at scale, and empowering development teams to deliver secure software efficiently.\nOutside of work, I enjoy exploring the beautiful Irish countryside, planning my next family trip, and cooking some Italian recipes.\nThrough this blog, I hope to share insights, best practices, and lessons learned from my experiences leading DevSecOps teams.\nYou can find more information about my CV on my LinkedIn profile.\nMy preavious blogs about Collaboration solutions are available here:\nitalian blog english blog ","permalink":"http://localhost:1313/aboutme/","tags":["biography"],"title":"About Me - Matteo Bisi"},{"content":"During the past few weeks, I have described what a secrets manager is and provided an overview of the architecture and system requirements of CyberArk Conjur.\nA secrets manager can’t do its job if it can’t communicate with those who need to request secrets, and that’s where Conjur’s magic comes in!\nThe “authenticators” are responsible for the authentication process in Conjur and are specialized to do this in the most secure way, depending on the service.\nHere is the list of authenticators currently supported:\nAuthenticator Description authn Defines the Conjur default authenticator. Authentication for both users and hosts is based on an ID and API key. authn-oidc Leverages the identity layer provided by OIDC to allow applications to authenticate with Conjur and retrieve secrets needed for connecting to services such as a database. [authn-iam(https://docs.cyberark.com/Product-Doc/OnlineHelp/AAM-DAP/Latest/en/Content/Operations/Services/AWS_IAM_Authenticator.htm)] Enables an AWS resource to use its AWS IAM role to authenticate with Conjur. authn-azure Enables an Azure resource to authenticate with Conjur authn-jwt Enables an application to authenticate to Conjur using a JWT from a JWT Provider. authn-gcp Enables a Google Cloud Platform resource to authenticate with Conjur authn-k8s Authenticates hosts that are Kubernetes resources, such as a Kubernetes namespace, deployment, stateful set, and others. Authentication is certificate-based using a mutual TLS connection. authn-ldap Authenticates users based on an LDAP directory. By default, after the initial setup, authn is the only authenticator enabled, and it is responsible for Conjur access using a username or API key (randomly generated between 51 and 56 characters).\nWhen integrations are needed, for example with a Kubernetes cluster, you need to activate and configure the authn-k8s authenticator. This authenticator can establish a secure mTLS connection compliant with the SPIFFE framework, as described in the following diagram (click here for more details).\nIf you need integrations with cloud identities that support JWT authentication, such as Google Apigee, you will enable the authn-jwt authenticator, which will perform the integrations as shown below:\nThese were just two examples among the many possible secure integrations enabled by the authenticators. The following is a more complete list:\nKubernetes (local or cloud) API gateway Jenkins Ansible Puppet Terraform Cloud services If the scenario described sounds interesting for your needs, Conjur could definitely be the right choice. Contact your sales representative at CyberArk or your preferred CyberArk business partner.\n","permalink":"http://localhost:1313/posts/cyberark-conjur-authenticators-integrations/","tags":["conjur","authenticators","spiffe","integrations"],"title":"CyberArk Conjur, authenticators and integrations"},{"content":"As I wrote in my last post, CyberArk Conjur is an enterprise secrets manager. , CyberArk Conjur is an enterprise secrets manager.\nIn this post, I’ll provide an architecture overview along with the main system requirements.\nConjur is currently available in two versions: Enterprise and open source (known as OSS).\nA “cloud” version will be available soon, offered as a SaaS solution.\nThis post focuses on the Enterprise version, which is similar but not identical to the OSS version.\nArchitecture Conjur is distributed as a Docker image, making deployment and configuration fast and secure.\nThe main services included in the appliance image are:\nnginx: Provides access to the administrative GUI and the API set for interacting with secrets. PostgreSQL database: Two databases, one for configurations and secrets, and one for audit logs. Conjur appliance: The core product. syslog-ng: Used to collect audit and access logs. The smallest common configuration for Conjur Enterprise is a three-node cluster with auto-failover, as shown in the following diagram:\nThe cluster architecture follows an active-passive model, with high availability guaranteed by a load balancer placed in front of the cluster. This load balancer switches the node accessed by applications in case of a failure.\nWithin the cluster, one node acts as the “leader node,” handling all read/write operations and providing the API for applications to interact with secrets.\nThe secondary nodes are called “standbys” and can be either synchronous or asynchronous, depending on the PostgreSQL replication setup.\nThese nodes are inactive and do not provide API services.\nIf the leader node fails, after a configurable period, the standbys will elect a new leader using etcd and the Raft consensus algorithm.\nIf auto-failover is not configured, manual promotion is required.\nIt is also possible to configure a primary site with auto-failover and a secondary site with asynchronous standbys (without auto-failover), ready to be promoted manually.\nThe final component of the architecture is the “follower,” a read-only replica of the leader. Followers allow secrets to be read at scale and are horizontally scalable components typically configured behind a load balancer to handle all types of read requests, including authentication, permission checks, and secret fetches.\nFollowers are usually installed on a Kubernetes cluster to serve applications with low latency.\nThe architecture diagram with followers could be expanded as shown below:\nSystem Requirements Production environment:\n4 cores 8 GB RAM 50 GB hard drive Test environment:\n2 cores 4 GB RAM 20 GB hard drive Supported container runtimes:\nDocker 1.13 or later Mirantis Container Runtime (MRC) 19.x, 20.10 on RHEL 8.x Kubernetes and OpenShift (only for the follower) Podman 3.3 and 3.4 The host server should run an operating system supported by the container runtime (the most popular are RHEL Server, RHEL-based, or Ubuntu Server LTS). To read more detail or updated versions please refer to this page.\nIf the customer environment also includes a CyberArk Vault server that needs to be synchronized with Conjur, the following are the requirements for a CyberArk Vault Synchronizer server:\n4 cores 8 GB RAM Windows Server 2012 R2 or later ","permalink":"http://localhost:1313/posts/cyberark-conjur-architecture-system-requirements/","tags":["conjur","cyberark","secrets manager"],"title":"CyberArk Conjur: A Quick Overview of Architecture and System Requirements"},{"content":"Security is always a complex topic to address, as an error or omission in processes can lead to serious economic or reputational damage for a company.\nWhen we talk about “secrets,” consider the following examples:\nUsernames Database passwords SSL certificates and keys SSH keys Cloud credentials Simply reading through this list helps to explain why this topic needs to be considered and handled carefully.\nSome common bad practices or risks include:\nHardcoding secrets in code Data breaches Password leaks Secrets pushed to public repositories With practices like lateral movement, just one compromised secret can be enough to compromise an entire environment. To help prevent these risks, there are tools known as “enterprise secrets managers.” I’d like to start a series of posts on this blog about CyberArk Conjur.\nConjur allows you to avoid direct use of secrets by leveraging a set of REST APIs, making it a programmable tool that can be accessed via URL or open source utilities.\nSecurity is enforced through security policies without slowing down the developers involved.\nCorporate security can be further improved with the use of rotators, which programmatically change secret values.\nIf other CyberArk software like PAS Vault is already in use, Conjur can be integrated using the Synchroniser component,\nproviding the same level of security for cloud-native infrastructure.\nConjur is available in two versions: enterprise and open source, each with distinct features.\nIn upcoming posts, I will explain details about the architecture, secrets management, and product news related to CyberArk Conjur.\n","permalink":"http://localhost:1313/posts/why-you-need-kubernetes-secrets-manager/","tags":["conjur","introduction","secrets manager"],"title":"CyberArk Conjur - why you (probably) need an enterprise secrets manager"},{"content":"Hello there! How are you?\nI’m really good! As you may have seen on my social media, starting from the 16th of May, I’ve begun a new position as Senior DevSecOps at SIGHUP.\nI’m really excited about this new opportunity, and I’m writing this post because it will also have an effect on this blog’s focus.\nThe topics will shift from previous subjects to cloud-native infrastructure security, starting with tools like CyberArk Conjur. The previous content on this blog will remain here forever. I believe it could be helpful for some time, and I also want to honor my HCL Ambassador role.\nI’d also love to add that my current role as organizer of the LetsConnect user group will remain unchanged.\nI hope to see you all again at our next event!\n","permalink":"http://localhost:1313/posts/new-job-devsecops-teamleader/","tags":["cloudnative","newjob","devsecops","security"],"title":"I've started a new journey as DevSecOps Team Leader"},{"content":"","permalink":"http://localhost:1313/search/","tags":null,"title":"Search"},{"content":"Hello, I’m Matteo Bisi.\nI’m a DevSecOps Team Leader currently living in Galway, Ireland, but originally from Italy.\nWith a passion for both technology and teamwork, I lead my team in building and securing cloud-native infrastructures using both open source and enterprise tools.\nMy journey has taken me across different roles, giving me a unique perspective on how diverse teams collaborate and innovate.\nI’m particularly interested in automating security practices, managing secrets at scale, and empowering development teams to deliver secure software efficiently.\nOutside of work, I enjoy exploring the beautiful Irish countryside, planning my next family trip, and cooking some Italian recipes.\nThrough this blog, I hope to share insights, best practices, and lessons learned from my experiences leading DevSecOps teams.\nYou can find more information about my CV on my LinkedIn profile.\nMy preavious blogs about Collaboration solutions are available here:\nitalian blog english blog ","permalink":"http://localhost:1313/aboutme/","tags":["biography"],"title":"About Me - Matteo Bisi"},{"content":"During the past few weeks, I have described what a secrets manager is and provided an overview of the architecture and system requirements of CyberArk Conjur.\nA secrets manager can’t do its job if it can’t communicate with those who need to request secrets, and that’s where Conjur’s magic comes in!\nThe “authenticators” are responsible for the authentication process in Conjur and are specialized to do this in the most secure way, depending on the service.\nHere is the list of authenticators currently supported:\nAuthenticator Description authn Defines the Conjur default authenticator. Authentication for both users and hosts is based on an ID and API key. authn-oidc Leverages the identity layer provided by OIDC to allow applications to authenticate with Conjur and retrieve secrets needed for connecting to services such as a database. [authn-iam(https://docs.cyberark.com/Product-Doc/OnlineHelp/AAM-DAP/Latest/en/Content/Operations/Services/AWS_IAM_Authenticator.htm)] Enables an AWS resource to use its AWS IAM role to authenticate with Conjur. authn-azure Enables an Azure resource to authenticate with Conjur authn-jwt Enables an application to authenticate to Conjur using a JWT from a JWT Provider. authn-gcp Enables a Google Cloud Platform resource to authenticate with Conjur authn-k8s Authenticates hosts that are Kubernetes resources, such as a Kubernetes namespace, deployment, stateful set, and others. Authentication is certificate-based using a mutual TLS connection. authn-ldap Authenticates users based on an LDAP directory. By default, after the initial setup, authn is the only authenticator enabled, and it is responsible for Conjur access using a username or API key (randomly generated between 51 and 56 characters).\nWhen integrations are needed, for example with a Kubernetes cluster, you need to activate and configure the authn-k8s authenticator. This authenticator can establish a secure mTLS connection compliant with the SPIFFE framework, as described in the following diagram (click here for more details).\nIf you need integrations with cloud identities that support JWT authentication, such as Google Apigee, you will enable the authn-jwt authenticator, which will perform the integrations as shown below:\nThese were just two examples among the many possible secure integrations enabled by the authenticators. The following is a more complete list:\nKubernetes (local or cloud) API gateway Jenkins Ansible Puppet Terraform Cloud services If the scenario described sounds interesting for your needs, Conjur could definitely be the right choice. Contact your sales representative at CyberArk or your preferred CyberArk business partner.\n","permalink":"http://localhost:1313/posts/cyberark-conjur-authenticators-integrations/","tags":["conjur","authenticators","spiffe","integrations"],"title":"CyberArk Conjur, authenticators and integrations"},{"content":"As I wrote in my last post, CyberArk Conjur is an enterprise secrets manager. , CyberArk Conjur is an enterprise secrets manager.\nIn this post, I’ll provide an architecture overview along with the main system requirements.\nConjur is currently available in two versions: Enterprise and open source (known as OSS).\nA “cloud” version will be available soon, offered as a SaaS solution.\nThis post focuses on the Enterprise version, which is similar but not identical to the OSS version.\nArchitecture Conjur is distributed as a Docker image, making deployment and configuration fast and secure.\nThe main services included in the appliance image are:\nnginx: Provides access to the administrative GUI and the API set for interacting with secrets. PostgreSQL database: Two databases, one for configurations and secrets, and one for audit logs. Conjur appliance: The core product. syslog-ng: Used to collect audit and access logs. The smallest common configuration for Conjur Enterprise is a three-node cluster with auto-failover, as shown in the following diagram:\nThe cluster architecture follows an active-passive model, with high availability guaranteed by a load balancer placed in front of the cluster. This load balancer switches the node accessed by applications in case of a failure.\nWithin the cluster, one node acts as the “leader node,” handling all read/write operations and providing the API for applications to interact with secrets.\nThe secondary nodes are called “standbys” and can be either synchronous or asynchronous, depending on the PostgreSQL replication setup.\nThese nodes are inactive and do not provide API services.\nIf the leader node fails, after a configurable period, the standbys will elect a new leader using etcd and the Raft consensus algorithm.\nIf auto-failover is not configured, manual promotion is required.\nIt is also possible to configure a primary site with auto-failover and a secondary site with asynchronous standbys (without auto-failover), ready to be promoted manually.\nThe final component of the architecture is the “follower,” a read-only replica of the leader. Followers allow secrets to be read at scale and are horizontally scalable components typically configured behind a load balancer to handle all types of read requests, including authentication, permission checks, and secret fetches.\nFollowers are usually installed on a Kubernetes cluster to serve applications with low latency.\nThe architecture diagram with followers could be expanded as shown below:\nSystem Requirements Production environment:\n4 cores 8 GB RAM 50 GB hard drive Test environment:\n2 cores 4 GB RAM 20 GB hard drive Supported container runtimes:\nDocker 1.13 or later Mirantis Container Runtime (MRC) 19.x, 20.10 on RHEL 8.x Kubernetes and OpenShift (only for the follower) Podman 3.3 and 3.4 The host server should run an operating system supported by the container runtime (the most popular are RHEL Server, RHEL-based, or Ubuntu Server LTS). To read more detail or updated versions please refer to this page.\nIf the customer environment also includes a CyberArk Vault server that needs to be synchronized with Conjur, the following are the requirements for a CyberArk Vault Synchronizer server:\n4 cores 8 GB RAM Windows Server 2012 R2 or later ","permalink":"http://localhost:1313/posts/cyberark-conjur-architecture-system-requirements/","tags":["conjur","cyberark","secrets manager"],"title":"CyberArk Conjur: A Quick Overview of Architecture and System Requirements"},{"content":"Security is always a complex topic to address, as an error or omission in processes can lead to serious economic or reputational damage for a company.\nWhen we talk about “secrets,” consider the following examples:\nUsernames Database passwords SSL certificates and keys SSH keys Cloud credentials Simply reading through this list helps to explain why this topic needs to be considered and handled carefully.\nSome common bad practices or risks include:\nHardcoding secrets in code Data breaches Password leaks Secrets pushed to public repositories With practices like lateral movement, just one compromised secret can be enough to compromise an entire environment. To help prevent these risks, there are tools known as “enterprise secrets managers.” I’d like to start a series of posts on this blog about CyberArk Conjur.\nConjur allows you to avoid direct use of secrets by leveraging a set of REST APIs, making it a programmable tool that can be accessed via URL or open source utilities.\nSecurity is enforced through security policies without slowing down the developers involved.\nCorporate security can be further improved with the use of rotators, which programmatically change secret values.\nIf other CyberArk software like PAS Vault is already in use, Conjur can be integrated using the Synchroniser component,\nproviding the same level of security for cloud-native infrastructure.\nConjur is available in two versions: enterprise and open source, each with distinct features.\nIn upcoming posts, I will explain details about the architecture, secrets management, and product news related to CyberArk Conjur.\n","permalink":"http://localhost:1313/posts/why-you-need-kubernetes-secrets-manager/","tags":["conjur","introduction","secrets manager"],"title":"CyberArk Conjur - why you (probably) need an enterprise secrets manager"},{"content":"Hello there! How are you?\nI’m really good! As you may have seen on my social media, starting from the 16th of May, I’ve begun a new position as Senior DevSecOps at SIGHUP.\nI’m really excited about this new opportunity, and I’m writing this post because it will also have an effect on this blog’s focus.\nThe topics will shift from previous subjects to cloud-native infrastructure security, starting with tools like CyberArk Conjur. The previous content on this blog will remain here forever. I believe it could be helpful for some time, and I also want to honor my HCL Ambassador role.\nI’d also love to add that my current role as organizer of the LetsConnect user group will remain unchanged.\nI hope to see you all again at our next event!\n","permalink":"http://localhost:1313/posts/new-job-devsecops-teamleader/","tags":["cloudnative","newjob","devsecops","security"],"title":"I've started a new journey as DevSecOps Team Leader"},{"content":"","permalink":"http://localhost:1313/search/","tags":null,"title":"Search"},{"content":"Hello, I’m Matteo Bisi.\nI’m a DevSecOps Team Leader currently living in Galway, Ireland, but originally from Italy.\nWith a passion for both technology and teamwork, I lead my team in building and securing cloud-native infrastructures using both open source and enterprise tools.\nMy journey has taken me across different roles, giving me a unique perspective on how diverse teams collaborate and innovate.\nI’m particularly interested in automating security practices, managing secrets at scale, and empowering development teams to deliver secure software efficiently.\nOutside of work, I enjoy exploring the beautiful Irish countryside, planning my next family trip, and cooking some Italian recipes.\nThrough this blog, I hope to share insights, best practices, and lessons learned from my experiences leading DevSecOps teams.\nYou can find more information about my CV on my LinkedIn profile.\nMy preavious blogs about Collaboration solutions are available here:\nitalian blog english blog ","permalink":"http://localhost:1313/aboutme/","tags":["biography"],"title":"About Me - Matteo Bisi"},{"content":"During the past few weeks, I have described what a secrets manager is and provided an overview of the architecture and system requirements of CyberArk Conjur.\nA secrets manager can’t do its job if it can’t communicate with those who need to request secrets, and that’s where Conjur’s magic comes in!\nThe “authenticators” are responsible for the authentication process in Conjur and are specialized to do this in the most secure way, depending on the service.\nHere is the list of authenticators currently supported:\nAuthenticator Description authn Defines the Conjur default authenticator. Authentication for both users and hosts is based on an ID and API key. authn-oidc Leverages the identity layer provided by OIDC to allow applications to authenticate with Conjur and retrieve secrets needed for connecting to services such as a database. [authn-iam(https://docs.cyberark.com/Product-Doc/OnlineHelp/AAM-DAP/Latest/en/Content/Operations/Services/AWS_IAM_Authenticator.htm)] Enables an AWS resource to use its AWS IAM role to authenticate with Conjur. authn-azure Enables an Azure resource to authenticate with Conjur authn-jwt Enables an application to authenticate to Conjur using a JWT from a JWT Provider. authn-gcp Enables a Google Cloud Platform resource to authenticate with Conjur authn-k8s Authenticates hosts that are Kubernetes resources, such as a Kubernetes namespace, deployment, stateful set, and others. Authentication is certificate-based using a mutual TLS connection. authn-ldap Authenticates users based on an LDAP directory. By default, after the initial setup, authn is the only authenticator enabled, and it is responsible for Conjur access using a username or API key (randomly generated between 51 and 56 characters).\nWhen integrations are needed, for example with a Kubernetes cluster, you need to activate and configure the authn-k8s authenticator. This authenticator can establish a secure mTLS connection compliant with the SPIFFE framework, as described in the following diagram (click here for more details).\nIf you need integrations with cloud identities that support JWT authentication, such as Google Apigee, you will enable the authn-jwt authenticator, which will perform the integrations as shown below:\nThese were just two examples among the many possible secure integrations enabled by the authenticators. The following is a more complete list:\nKubernetes (local or cloud) API gateway Jenkins Ansible Puppet Terraform Cloud services If the scenario described sounds interesting for your needs, Conjur could definitely be the right choice. Contact your sales representative at CyberArk or your preferred CyberArk business partner.\n","permalink":"http://localhost:1313/posts/cyberark-conjur-authenticators-integrations/","tags":["conjur","authenticators","spiffe","integrations"],"title":"CyberArk Conjur, authenticators and integrations"},{"content":"As I wrote in my last post, CyberArk Conjur is an enterprise secrets manager. , CyberArk Conjur is an enterprise secrets manager.\nIn this post, I’ll provide an architecture overview along with the main system requirements.\nConjur is currently available in two versions: Enterprise and open source (known as OSS).\nA “cloud” version will be available soon, offered as a SaaS solution.\nThis post focuses on the Enterprise version, which is similar but not identical to the OSS version.\nArchitecture Conjur is distributed as a Docker image, making deployment and configuration fast and secure.\nThe main services included in the appliance image are:\nnginx: Provides access to the administrative GUI and the API set for interacting with secrets. PostgreSQL database: Two databases, one for configurations and secrets, and one for audit logs. Conjur appliance: The core product. syslog-ng: Used to collect audit and access logs. The smallest common configuration for Conjur Enterprise is a three-node cluster with auto-failover, as shown in the following diagram:\nThe cluster architecture follows an active-passive model, with high availability guaranteed by a load balancer placed in front of the cluster. This load balancer switches the node accessed by applications in case of a failure.\nWithin the cluster, one node acts as the “leader node,” handling all read/write operations and providing the API for applications to interact with secrets.\nThe secondary nodes are called “standbys” and can be either synchronous or asynchronous, depending on the PostgreSQL replication setup.\nThese nodes are inactive and do not provide API services.\nIf the leader node fails, after a configurable period, the standbys will elect a new leader using etcd and the Raft consensus algorithm.\nIf auto-failover is not configured, manual promotion is required.\nIt is also possible to configure a primary site with auto-failover and a secondary site with asynchronous standbys (without auto-failover), ready to be promoted manually.\nThe final component of the architecture is the “follower,” a read-only replica of the leader. Followers allow secrets to be read at scale and are horizontally scalable components typically configured behind a load balancer to handle all types of read requests, including authentication, permission checks, and secret fetches.\nFollowers are usually installed on a Kubernetes cluster to serve applications with low latency.\nThe architecture diagram with followers could be expanded as shown below:\nSystem Requirements Production environment:\n4 cores 8 GB RAM 50 GB hard drive Test environment:\n2 cores 4 GB RAM 20 GB hard drive Supported container runtimes:\nDocker 1.13 or later Mirantis Container Runtime (MRC) 19.x, 20.10 on RHEL 8.x Kubernetes and OpenShift (only for the follower) Podman 3.3 and 3.4 The host server should run an operating system supported by the container runtime (the most popular are RHEL Server, RHEL-based, or Ubuntu Server LTS). To read more detail or updated versions please refer to this page.\nIf the customer environment also includes a CyberArk Vault server that needs to be synchronized with Conjur, the following are the requirements for a CyberArk Vault Synchronizer server:\n4 cores 8 GB RAM Windows Server 2012 R2 or later ","permalink":"http://localhost:1313/posts/cyberark-conjur-architecture-system-requirements/","tags":["conjur","cyberark","secrets manager"],"title":"CyberArk Conjur: A Quick Overview of Architecture and System Requirements"},{"content":"Security is always a complex topic to address, as an error or omission in processes can lead to serious economic or reputational damage for a company.\nWhen we talk about “secrets,” consider the following examples:\nUsernames Database passwords SSL certificates and keys SSH keys Cloud credentials Simply reading through this list helps to explain why this topic needs to be considered and handled carefully.\nSome common bad practices or risks include:\nHardcoding secrets in code Data breaches Password leaks Secrets pushed to public repositories With practices like lateral movement, just one compromised secret can be enough to compromise an entire environment. To help prevent these risks, there are tools known as “enterprise secrets managers.” I’d like to start a series of posts on this blog about CyberArk Conjur.\nConjur allows you to avoid direct use of secrets by leveraging a set of REST APIs, making it a programmable tool that can be accessed via URL or open source utilities.\nSecurity is enforced through security policies without slowing down the developers involved.\nCorporate security can be further improved with the use of rotators, which programmatically change secret values.\nIf other CyberArk software like PAS Vault is already in use, Conjur can be integrated using the Synchroniser component,\nproviding the same level of security for cloud-native infrastructure.\nConjur is available in two versions: enterprise and open source, each with distinct features.\nIn upcoming posts, I will explain details about the architecture, secrets management, and product news related to CyberArk Conjur.\n","permalink":"http://localhost:1313/posts/why-you-need-kubernetes-secrets-manager/","tags":["conjur","introduction","secrets manager"],"title":"CyberArk Conjur - why you (probably) need an enterprise secrets manager"},{"content":"Hello there! How are you?\nI’m really good! As you may have seen on my social media, starting from the 16th of May, I’ve begun a new position as Senior DevSecOps at SIGHUP.\nI’m really excited about this new opportunity, and I’m writing this post because it will also have an effect on this blog’s focus.\nThe topics will shift from previous subjects to cloud-native infrastructure security, starting with tools like CyberArk Conjur. The previous content on this blog will remain here forever. I believe it could be helpful for some time, and I also want to honor my HCL Ambassador role.\nI’d also love to add that my current role as organizer of the LetsConnect user group will remain unchanged.\nI hope to see you all again at our next event!\n","permalink":"http://localhost:1313/posts/new-job-devsecops-teamleader/","tags":["cloudnative","newjob","devsecops","security"],"title":"I've started a new journey as DevSecOps Team Leader"},{"content":"","permalink":"http://localhost:1313/search/","tags":null,"title":"Search"},{"content":"Hello, I’m Matteo Bisi.\nI’m a DevSecOps Team Leader currently living in Galway, Ireland, but originally from Italy.\nWith a passion for both technology and teamwork, I lead my team in building and securing cloud-native infrastructures using both open source and enterprise tools.\nMy journey has taken me across different roles, giving me a unique perspective on how diverse teams collaborate and innovate.\nI’m particularly interested in automating security practices, managing secrets at scale, and empowering development teams to deliver secure software efficiently.\nOutside of work, I enjoy exploring the beautiful Irish countryside, planning my next family trip, and cooking some Italian recipes.\nThrough this blog, I hope to share insights, best practices, and lessons learned from my experiences leading DevSecOps teams.\nYou can find more information about my CV on my LinkedIn profile.\nMy preavious blogs about Collaboration solutions are available here:\nitalian blog english blog ","permalink":"http://localhost:1313/aboutme/","tags":["biography"],"title":"About Me - Matteo Bisi"},{"content":"During the past few weeks, I have described what a secrets manager is and provided an overview of the architecture and system requirements of CyberArk Conjur.\nA secrets manager can’t do its job if it can’t communicate with those who need to request secrets, and that’s where Conjur’s magic comes in!\nThe “authenticators” are responsible for the authentication process in Conjur and are specialized to do this in the most secure way, depending on the service.\nHere is the list of authenticators currently supported:\nAuthenticator Description authn Defines the Conjur default authenticator. Authentication for both users and hosts is based on an ID and API key. authn-oidc Leverages the identity layer provided by OIDC to allow applications to authenticate with Conjur and retrieve secrets needed for connecting to services such as a database. [authn-iam(https://docs.cyberark.com/Product-Doc/OnlineHelp/AAM-DAP/Latest/en/Content/Operations/Services/AWS_IAM_Authenticator.htm)] Enables an AWS resource to use its AWS IAM role to authenticate with Conjur. authn-azure Enables an Azure resource to authenticate with Conjur authn-jwt Enables an application to authenticate to Conjur using a JWT from a JWT Provider. authn-gcp Enables a Google Cloud Platform resource to authenticate with Conjur authn-k8s Authenticates hosts that are Kubernetes resources, such as a Kubernetes namespace, deployment, stateful set, and others. Authentication is certificate-based using a mutual TLS connection. authn-ldap Authenticates users based on an LDAP directory. By default, after the initial setup, authn is the only authenticator enabled, and it is responsible for Conjur access using a username or API key (randomly generated between 51 and 56 characters).\nWhen integrations are needed, for example with a Kubernetes cluster, you need to activate and configure the authn-k8s authenticator. This authenticator can establish a secure mTLS connection compliant with the SPIFFE framework, as described in the following diagram (click here for more details).\nIf you need integrations with cloud identities that support JWT authentication, such as Google Apigee, you will enable the authn-jwt authenticator, which will perform the integrations as shown below:\nThese were just two examples among the many possible secure integrations enabled by the authenticators. The following is a more complete list:\nKubernetes (local or cloud) API gateway Jenkins Ansible Puppet Terraform Cloud services If the scenario described sounds interesting for your needs, Conjur could definitely be the right choice. Contact your sales representative at CyberArk or your preferred CyberArk business partner.\n","permalink":"http://localhost:1313/posts/cyberark-conjur-authenticators-integrations/","tags":["conjur","authenticators","spiffe","integrations"],"title":"CyberArk Conjur, authenticators and integrations"},{"content":"As I wrote in my last post, CyberArk Conjur is an enterprise secrets manager. , CyberArk Conjur is an enterprise secrets manager.\nIn this post, I’ll provide an architecture overview along with the main system requirements.\nConjur is currently available in two versions: Enterprise and open source (known as OSS).\nA “cloud” version will be available soon, offered as a SaaS solution.\nThis post focuses on the Enterprise version, which is similar but not identical to the OSS version.\nArchitecture Conjur is distributed as a Docker image, making deployment and configuration fast and secure.\nThe main services included in the appliance image are:\nnginx: Provides access to the administrative GUI and the API set for interacting with secrets. PostgreSQL database: Two databases, one for configurations and secrets, and one for audit logs. Conjur appliance: The core product. syslog-ng: Used to collect audit and access logs. The smallest common configuration for Conjur Enterprise is a three-node cluster with auto-failover, as shown in the following diagram:\nThe cluster architecture follows an active-passive model, with high availability guaranteed by a load balancer placed in front of the cluster. This load balancer switches the node accessed by applications in case of a failure.\nWithin the cluster, one node acts as the “leader node,” handling all read/write operations and providing the API for applications to interact with secrets.\nThe secondary nodes are called “standbys” and can be either synchronous or asynchronous, depending on the PostgreSQL replication setup.\nThese nodes are inactive and do not provide API services.\nIf the leader node fails, after a configurable period, the standbys will elect a new leader using etcd and the Raft consensus algorithm.\nIf auto-failover is not configured, manual promotion is required.\nIt is also possible to configure a primary site with auto-failover and a secondary site with asynchronous standbys (without auto-failover), ready to be promoted manually.\nThe final component of the architecture is the “follower,” a read-only replica of the leader. Followers allow secrets to be read at scale and are horizontally scalable components typically configured behind a load balancer to handle all types of read requests, including authentication, permission checks, and secret fetches.\nFollowers are usually installed on a Kubernetes cluster to serve applications with low latency.\nThe architecture diagram with followers could be expanded as shown below:\nSystem Requirements Production environment:\n4 cores 8 GB RAM 50 GB hard drive Test environment:\n2 cores 4 GB RAM 20 GB hard drive Supported container runtimes:\nDocker 1.13 or later Mirantis Container Runtime (MRC) 19.x, 20.10 on RHEL 8.x Kubernetes and OpenShift (only for the follower) Podman 3.3 and 3.4 The host server should run an operating system supported by the container runtime (the most popular are RHEL Server, RHEL-based, or Ubuntu Server LTS). To read more detail or updated versions please refer to this page.\nIf the customer environment also includes a CyberArk Vault server that needs to be synchronized with Conjur, the following are the requirements for a CyberArk Vault Synchronizer server:\n4 cores 8 GB RAM Windows Server 2012 R2 or later ","permalink":"http://localhost:1313/posts/cyberark-conjur-architecture-system-requirements/","tags":["conjur","cyberark","secrets manager"],"title":"CyberArk Conjur: A Quick Overview of Architecture and System Requirements"},{"content":"Security is always a complex topic to address, as an error or omission in processes can lead to serious economic or reputational damage for a company.\nWhen we talk about “secrets,” consider the following examples:\nUsernames Database passwords SSL certificates and keys SSH keys Cloud credentials Simply reading through this list helps to explain why this topic needs to be considered and handled carefully.\nSome common bad practices or risks include:\nHardcoding secrets in code Data breaches Password leaks Secrets pushed to public repositories With practices like lateral movement, just one compromised secret can be enough to compromise an entire environment. To help prevent these risks, there are tools known as “enterprise secrets managers.” I’d like to start a series of posts on this blog about CyberArk Conjur.\nConjur allows you to avoid direct use of secrets by leveraging a set of REST APIs, making it a programmable tool that can be accessed via URL or open source utilities.\nSecurity is enforced through security policies without slowing down the developers involved.\nCorporate security can be further improved with the use of rotators, which programmatically change secret values.\nIf other CyberArk software like PAS Vault is already in use, Conjur can be integrated using the Synchroniser component,\nproviding the same level of security for cloud-native infrastructure.\nConjur is available in two versions: enterprise and open source, each with distinct features.\nIn upcoming posts, I will explain details about the architecture, secrets management, and product news related to CyberArk Conjur.\n","permalink":"http://localhost:1313/posts/why-you-need-kubernetes-secrets-manager/","tags":["conjur","introduction","secrets manager"],"title":"CyberArk Conjur - why you (probably) need an enterprise secrets manager"},{"content":"Hello there! How are you?\nI’m really good! As you may have seen on my social media, starting from the 16th of May, I’ve begun a new position as Senior DevSecOps at SIGHUP.\nI’m really excited about this new opportunity, and I’m writing this post because it will also have an effect on this blog’s focus.\nThe topics will shift from previous subjects to cloud-native infrastructure security, starting with tools like CyberArk Conjur. The previous content on this blog will remain here forever. I believe it could be helpful for some time, and I also want to honor my HCL Ambassador role.\nI’d also love to add that my current role as organizer of the LetsConnect user group will remain unchanged.\nI hope to see you all again at our next event!\n","permalink":"http://localhost:1313/posts/new-job-devsecops-teamleader/","tags":["cloudnative","newjob","devsecops","security"],"title":"I've started a new journey as DevSecOps Team Leader"},{"content":"","permalink":"http://localhost:1313/search/","tags":null,"title":"Search"},{"content":"Hello, I’m Matteo Bisi.\nI’m a DevSecOps Team Leader currently living in Galway, Ireland, but originally from Italy.\nWith a passion for both technology and teamwork, I lead my team in building and securing cloud-native infrastructures using both open source and enterprise tools.\nMy journey has taken me across different roles, giving me a unique perspective on how diverse teams collaborate and innovate.\nI’m particularly interested in automating security practices, managing secrets at scale, and empowering development teams to deliver secure software efficiently.\nOutside of work, I enjoy exploring the beautiful Irish countryside, planning my next family trip, and cooking some Italian recipes.\nThrough this blog, I hope to share insights, best practices, and lessons learned from my experiences leading DevSecOps teams.\nYou can find more information about my CV on my LinkedIn profile.\nMy preavious blogs about Collaboration solutions are available here:\nitalian blog english blog ","permalink":"http://localhost:1313/aboutme/","tags":["biography"],"title":"About Me - Matteo Bisi"},{"content":"During the past few weeks, I have described what a secrets manager is and provided an overview of the architecture and system requirements of CyberArk Conjur.\nA secrets manager can’t do its job if it can’t communicate with those who need to request secrets, and that’s where Conjur’s magic comes in!\nThe “authenticators” are responsible for the authentication process in Conjur and are specialized to do this in the most secure way, depending on the service.\nHere is the list of authenticators currently supported:\nAuthenticator Description authn Defines the Conjur default authenticator. Authentication for both users and hosts is based on an ID and API key. authn-oidc Leverages the identity layer provided by OIDC to allow applications to authenticate with Conjur and retrieve secrets needed for connecting to services such as a database. authn-iam Enables an AWS resource to use its AWS IAM role to authenticate with Conjur. authn-azure Enables an Azure resource to authenticate with Conjur authn-jwt Enables an application to authenticate to Conjur using a JWT from a JWT Provider. authn-gcp Enables a Google Cloud Platform resource to authenticate with Conjur authn-k8s Authenticates hosts that are Kubernetes resources, such as a Kubernetes namespace, deployment, stateful set, and others. Authentication is certificate-based using a mutual TLS connection. authn-ldap Authenticates users based on an LDAP directory. By default, after the initial setup, authn is the only authenticator enabled, and it is responsible for Conjur access using a username or API key (randomly generated between 51 and 56 characters).\nWhen integrations are needed, for example with a Kubernetes cluster, you need to activate and configure the authn-k8s authenticator. This authenticator can establish a secure mTLS connection compliant with the SPIFFE framework, as described in the following diagram (click here for more details).\nIf you need integrations with cloud identities that support JWT authentication, such as Google Apigee, you will enable the authn-jwt authenticator, which will perform the integrations as shown below:\nThese were just two examples among the many possible secure integrations enabled by the authenticators. The following is a more complete list:\nKubernetes (local or cloud) API gateway Jenkins Ansible Puppet Terraform Cloud services If the scenario described sounds interesting for your needs, Conjur could definitely be the right choice. Contact your sales representative at CyberArk or your preferred CyberArk business partner.\n","permalink":"http://localhost:1313/posts/cyberark-conjur-authenticators-integrations/","tags":["conjur","authenticators","spiffe","integrations"],"title":"CyberArk Conjur, authenticators and integrations"},{"content":"As I wrote in my last post, CyberArk Conjur is an enterprise secrets manager. , CyberArk Conjur is an enterprise secrets manager.\nIn this post, I’ll provide an architecture overview along with the main system requirements.\nConjur is currently available in two versions: Enterprise and open source (known as OSS).\nA “cloud” version will be available soon, offered as a SaaS solution.\nThis post focuses on the Enterprise version, which is similar but not identical to the OSS version.\nArchitecture Conjur is distributed as a Docker image, making deployment and configuration fast and secure.\nThe main services included in the appliance image are:\nnginx: Provides access to the administrative GUI and the API set for interacting with secrets. PostgreSQL database: Two databases, one for configurations and secrets, and one for audit logs. Conjur appliance: The core product. syslog-ng: Used to collect audit and access logs. The smallest common configuration for Conjur Enterprise is a three-node cluster with auto-failover, as shown in the following diagram:\nThe cluster architecture follows an active-passive model, with high availability guaranteed by a load balancer placed in front of the cluster. This load balancer switches the node accessed by applications in case of a failure.\nWithin the cluster, one node acts as the “leader node,” handling all read/write operations and providing the API for applications to interact with secrets.\nThe secondary nodes are called “standbys” and can be either synchronous or asynchronous, depending on the PostgreSQL replication setup.\nThese nodes are inactive and do not provide API services.\nIf the leader node fails, after a configurable period, the standbys will elect a new leader using etcd and the Raft consensus algorithm.\nIf auto-failover is not configured, manual promotion is required.\nIt is also possible to configure a primary site with auto-failover and a secondary site with asynchronous standbys (without auto-failover), ready to be promoted manually.\nThe final component of the architecture is the “follower,” a read-only replica of the leader. Followers allow secrets to be read at scale and are horizontally scalable components typically configured behind a load balancer to handle all types of read requests, including authentication, permission checks, and secret fetches.\nFollowers are usually installed on a Kubernetes cluster to serve applications with low latency.\nThe architecture diagram with followers could be expanded as shown below:\nSystem Requirements Production environment:\n4 cores 8 GB RAM 50 GB hard drive Test environment:\n2 cores 4 GB RAM 20 GB hard drive Supported container runtimes:\nDocker 1.13 or later Mirantis Container Runtime (MRC) 19.x, 20.10 on RHEL 8.x Kubernetes and OpenShift (only for the follower) Podman 3.3 and 3.4 The host server should run an operating system supported by the container runtime (the most popular are RHEL Server, RHEL-based, or Ubuntu Server LTS). To read more detail or updated versions please refer to this page.\nIf the customer environment also includes a CyberArk Vault server that needs to be synchronized with Conjur, the following are the requirements for a CyberArk Vault Synchronizer server:\n4 cores 8 GB RAM Windows Server 2012 R2 or later ","permalink":"http://localhost:1313/posts/cyberark-conjur-architecture-system-requirements/","tags":["conjur","cyberark","secrets manager"],"title":"CyberArk Conjur: A Quick Overview of Architecture and System Requirements"},{"content":"Security is always a complex topic to address, as an error or omission in processes can lead to serious economic or reputational damage for a company.\nWhen we talk about “secrets,” consider the following examples:\nUsernames Database passwords SSL certificates and keys SSH keys Cloud credentials Simply reading through this list helps to explain why this topic needs to be considered and handled carefully.\nSome common bad practices or risks include:\nHardcoding secrets in code Data breaches Password leaks Secrets pushed to public repositories With practices like lateral movement, just one compromised secret can be enough to compromise an entire environment. To help prevent these risks, there are tools known as “enterprise secrets managers.” I’d like to start a series of posts on this blog about CyberArk Conjur.\nConjur allows you to avoid direct use of secrets by leveraging a set of REST APIs, making it a programmable tool that can be accessed via URL or open source utilities.\nSecurity is enforced through security policies without slowing down the developers involved.\nCorporate security can be further improved with the use of rotators, which programmatically change secret values.\nIf other CyberArk software like PAS Vault is already in use, Conjur can be integrated using the Synchroniser component,\nproviding the same level of security for cloud-native infrastructure.\nConjur is available in two versions: enterprise and open source, each with distinct features.\nIn upcoming posts, I will explain details about the architecture, secrets management, and product news related to CyberArk Conjur.\n","permalink":"http://localhost:1313/posts/why-you-need-kubernetes-secrets-manager/","tags":["conjur","introduction","secrets manager"],"title":"CyberArk Conjur - why you (probably) need an enterprise secrets manager"},{"content":"Hello there! How are you?\nI’m really good! As you may have seen on my social media, starting from the 16th of May, I’ve begun a new position as Senior DevSecOps at SIGHUP.\nI’m really excited about this new opportunity, and I’m writing this post because it will also have an effect on this blog’s focus.\nThe topics will shift from previous subjects to cloud-native infrastructure security, starting with tools like CyberArk Conjur. The previous content on this blog will remain here forever. I believe it could be helpful for some time, and I also want to honor my HCL Ambassador role.\nI’d also love to add that my current role as organizer of the LetsConnect user group will remain unchanged.\nI hope to see you all again at our next event!\n","permalink":"http://localhost:1313/posts/new-job-devsecops-teamleader/","tags":["cloudnative","newjob","devsecops","security"],"title":"I've started a new journey as DevSecOps Team Leader"},{"content":"","permalink":"http://localhost:1313/search/","tags":null,"title":"Search"},{"content":"Hello, I’m Matteo Bisi.\nI’m a DevSecOps Team Leader currently living in Galway, Ireland, but originally from Italy.\nWith a passion for both technology and teamwork, I lead my team in building and securing cloud-native infrastructures using both open source and enterprise tools.\nMy journey has taken me across different roles, giving me a unique perspective on how diverse teams collaborate and innovate.\nI’m particularly interested in automating security practices, managing secrets at scale, and empowering development teams to deliver secure software efficiently.\nOutside of work, I enjoy exploring the beautiful Irish countryside, planning my next family trip, and cooking some Italian recipes.\nThrough this blog, I hope to share insights, best practices, and lessons learned from my experiences leading DevSecOps teams.\nYou can find more information about my CV on my LinkedIn profile.\nMy preavious blogs about Collaboration solutions are available here:\nitalian blog english blog ","permalink":"http://localhost:1313/aboutme/","tags":["biography"],"title":"About Me - Matteo Bisi"},{"content":"During the past few weeks, I have described what a secrets manager is and provided an overview of the architecture and system requirements of CyberArk Conjur.\nA secrets manager can’t do its job if it can’t communicate with those who need to request secrets, and that’s where Conjur’s magic comes in!\nThe “authenticators” are responsible for the authentication process in Conjur and are specialized to do this in the most secure way, depending on the service.\nHere is the list of authenticators currently supported:\nAuthenticator Description authn Defines the Conjur default authenticator. Authentication for both users and hosts is based on an ID and API key. authn-oidc Leverages the identity layer provided by OIDC to allow applications to authenticate with Conjur and retrieve secrets needed for connecting to services such as a database. authn-iam Enables an AWS resource to use its AWS IAM role to authenticate with Conjur. authn-azure Enables an Azure resource to authenticate with Conjur authn-jwt Enables an application to authenticate to Conjur using a JWT from a JWT Provider. authn-gcp Enables a Google Cloud Platform resource to authenticate with Conjur authn-k8s Authenticates hosts that are Kubernetes resources, such as a Kubernetes namespace, deployment, stateful set, and others. Authentication is certificate-based using a mutual TLS connection. authn-ldap Authenticates users based on an LDAP directory. By default, after the initial setup, authn is the only authenticator enabled, and it is responsible for Conjur access using a username or API key (randomly generated between 51 and 56 characters).\nWhen integrations are needed, for example with a Kubernetes cluster, you need to activate and configure the authn-k8s authenticator. This authenticator can establish a secure mTLS connection compliant with the SPIFFE framework, as described in the following diagram (click here for more details).\nIf you need integrations with cloud identities that support JWT authentication, such as Google Apigee, you will enable the authn-jwt authenticator, which will perform the integrations as shown below:\nThese were just two examples among the many possible secure integrations enabled by the authenticators. The following is a more complete list:\nKubernetes (local or cloud) API gateway Jenkins Ansible Puppet Terraform Cloud services If the scenario described sounds interesting for your needs, Conjur could definitely be the right choice. Contact your sales representative at CyberArk or your preferred CyberArk business partner.\n","permalink":"http://localhost:1313/posts/cyberark-conjur-authenticators-integrations/","tags":["conjur","authenticators","spiffe","integrations"],"title":"CyberArk Conjur, authenticators and integrations"},{"content":"As I wrote in my last post, CyberArk Conjur is an enterprise secrets manager. , CyberArk Conjur is an enterprise secrets manager.\nIn this post, I’ll provide an architecture overview along with the main system requirements.\nConjur is currently available in two versions: Enterprise and open source (known as OSS).\nA “cloud” version will be available soon, offered as a SaaS solution.\nThis post focuses on the Enterprise version, which is similar but not identical to the OSS version.\nArchitecture Conjur is distributed as a Docker image, making deployment and configuration fast and secure.\nThe main services included in the appliance image are:\nnginx: Provides access to the administrative GUI and the API set for interacting with secrets. PostgreSQL database: Two databases, one for configurations and secrets, and one for audit logs. Conjur appliance: The core product. syslog-ng: Used to collect audit and access logs. The smallest common configuration for Conjur Enterprise is a three-node cluster with auto-failover, as shown in the following diagram:\nThe cluster architecture follows an active-passive model, with high availability guaranteed by a load balancer placed in front of the cluster. This load balancer switches the node accessed by applications in case of a failure.\nWithin the cluster, one node acts as the “leader node,” handling all read/write operations and providing the API for applications to interact with secrets.\nThe secondary nodes are called “standbys” and can be either synchronous or asynchronous, depending on the PostgreSQL replication setup.\nThese nodes are inactive and do not provide API services.\nIf the leader node fails, after a configurable period, the standbys will elect a new leader using etcd and the Raft consensus algorithm.\nIf auto-failover is not configured, manual promotion is required.\nIt is also possible to configure a primary site with auto-failover and a secondary site with asynchronous standbys (without auto-failover), ready to be promoted manually.\nThe final component of the architecture is the “follower,” a read-only replica of the leader. Followers allow secrets to be read at scale and are horizontally scalable components typically configured behind a load balancer to handle all types of read requests, including authentication, permission checks, and secret fetches.\nFollowers are usually installed on a Kubernetes cluster to serve applications with low latency.\nThe architecture diagram with followers could be expanded as shown below:\nSystem Requirements Production environment:\n4 cores 8 GB RAM 50 GB hard drive Test environment:\n2 cores 4 GB RAM 20 GB hard drive Supported container runtimes:\nDocker 1.13 or later Mirantis Container Runtime (MRC) 19.x, 20.10 on RHEL 8.x Kubernetes and OpenShift (only for the follower) Podman 3.3 and 3.4 The host server should run an operating system supported by the container runtime (the most popular are RHEL Server, RHEL-based, or Ubuntu Server LTS). To read more detail or updated versions please refer to this page.\nIf the customer environment also includes a CyberArk Vault server that needs to be synchronized with Conjur, the following are the requirements for a CyberArk Vault Synchronizer server:\n4 cores 8 GB RAM Windows Server 2012 R2 or later ","permalink":"http://localhost:1313/posts/cyberark-conjur-architecture-system-requirements/","tags":["conjur","cyberark","secrets manager"],"title":"CyberArk Conjur: A Quick Overview of Architecture and System Requirements"},{"content":"Security is always a complex topic to address, as an error or omission in processes can lead to serious economic or reputational damage for a company.\nWhen we talk about “secrets,” consider the following examples:\nUsernames Database passwords SSL certificates and keys SSH keys Cloud credentials Simply reading through this list helps to explain why this topic needs to be considered and handled carefully.\nSome common bad practices or risks include:\nHardcoding secrets in code Data breaches Password leaks Secrets pushed to public repositories With practices like lateral movement, just one compromised secret can be enough to compromise an entire environment. To help prevent these risks, there are tools known as “enterprise secrets managers.” I’d like to start a series of posts on this blog about CyberArk Conjur.\nConjur allows you to avoid direct use of secrets by leveraging a set of REST APIs, making it a programmable tool that can be accessed via URL or open source utilities.\nSecurity is enforced through security policies without slowing down the developers involved.\nCorporate security can be further improved with the use of rotators, which programmatically change secret values.\nIf other CyberArk software like PAS Vault is already in use, Conjur can be integrated using the Synchroniser component,\nproviding the same level of security for cloud-native infrastructure.\nConjur is available in two versions: enterprise and open source, each with distinct features.\nIn upcoming posts, I will explain details about the architecture, secrets management, and product news related to CyberArk Conjur.\n","permalink":"http://localhost:1313/posts/why-you-need-kubernetes-secrets-manager/","tags":["conjur","introduction","secrets manager"],"title":"CyberArk Conjur - why you (probably) need an enterprise secrets manager"},{"content":"Hello there! How are you?\nI’m really good! As you may have seen on my social media, starting from the 16th of May, I’ve begun a new position as Senior DevSecOps at SIGHUP.\nI’m really excited about this new opportunity, and I’m writing this post because it will also have an effect on this blog’s focus.\nThe topics will shift from previous subjects to cloud-native infrastructure security, starting with tools like CyberArk Conjur. The previous content on this blog will remain here forever. I believe it could be helpful for some time, and I also want to honor my HCL Ambassador role.\nI’d also love to add that my current role as organizer of the LetsConnect user group will remain unchanged.\nI hope to see you all again at our next event!\n","permalink":"http://localhost:1313/posts/new-job-devsecops-teamleader/","tags":["cloudnative","newjob","devsecops","security"],"title":"I've started a new journey as DevSecOps Team Leader"},{"content":"","permalink":"http://localhost:1313/search/","tags":null,"title":"Search"},{"content":"Hello, I’m Matteo Bisi.\nI’m a DevSecOps Team Leader currently living in Galway, Ireland, but originally from Italy.\nWith a passion for both technology and teamwork, I lead my team in building and securing cloud-native infrastructures using both open source and enterprise tools.\nMy journey has taken me across different roles, giving me a unique perspective on how diverse teams collaborate and innovate.\nI’m particularly interested in automating security practices, managing secrets at scale, and empowering development teams to deliver secure software efficiently.\nOutside of work, I enjoy exploring the beautiful Irish countryside, planning my next family trip, and cooking some Italian recipes.\nThrough this blog, I hope to share insights, best practices, and lessons learned from my experiences leading DevSecOps teams.\nYou can find more information about my CV on my LinkedIn profile.\nMy preavious blogs about Collaboration solutions are available here:\nitalian blog english blog ","permalink":"http://localhost:1313/aboutme/","tags":["biography"],"title":"About Me - Matteo Bisi"},{"content":"During the past few weeks, I have described what a secrets manager is and provided an overview of the architecture and system requirements of CyberArk Conjur.\nA secrets manager can’t do its job if it can’t communicate with those who need to request secrets, and that’s where Conjur’s magic comes in!\nThe “authenticators” are responsible for the authentication process in Conjur and are specialized to do this in the most secure way, depending on the service.\nHere is the list of authenticators currently supported:\nAuthenticator Description authn Defines the Conjur default authenticator. Authentication for both users and hosts is based on an ID and API key. authn-oidc Leverages the identity layer provided by OIDC to allow applications to authenticate with Conjur and retrieve secrets needed for connecting to services such as a database. authn-iam Enables an AWS resource to use its AWS IAM role to authenticate with Conjur. authn-azure Enables an Azure resource to authenticate with Conjur authn-jwt Enables an application to authenticate to Conjur using a JWT from a JWT Provider. authn-gcp Enables a Google Cloud Platform resource to authenticate with Conjur authn-k8s Authenticates hosts that are Kubernetes resources, such as a Kubernetes namespace, deployment, stateful set, and others. Authentication is certificate-based using a mutual TLS connection. authn-ldap Authenticates users based on an LDAP directory. By default, after the initial setup, authn is the only authenticator enabled, and it is responsible for Conjur access using a username or API key (randomly generated between 51 and 56 characters).\nWhen integrations are needed, for example with a Kubernetes cluster, you need to activate and configure the authn-k8s authenticator. This authenticator can establish a secure mTLS connection compliant with the SPIFFE framework, as described in the following diagram (click here for more details).\nIf you need integrations with cloud identities that support JWT authentication, such as Google Apigee, you will enable the authn-jwt authenticator, which will perform the integrations as shown below:\nThese were just two examples among the many possible secure integrations enabled by the authenticators. The following is a more complete list:\nKubernetes (local or cloud) API gateway Jenkins Ansible Puppet Terraform Cloud services If the scenario described sounds interesting for your needs, Conjur could definitely be the right choice. Contact your sales representative at CyberArk or your preferred CyberArk business partner.\n","permalink":"http://localhost:1313/posts/cyberark-conjur-authenticators-integrations/","tags":["conjur","authenticators","spiffe","integrations"],"title":"CyberArk Conjur, authenticators and integrations"},{"content":"As I wrote in my last post, CyberArk Conjur is an enterprise secrets manager. , CyberArk Conjur is an enterprise secrets manager.\nIn this post, I’ll provide an architecture overview along with the main system requirements.\nConjur is currently available in two versions: Enterprise and open source (known as OSS).\nA “cloud” version will be available soon, offered as a SaaS solution.\nThis post focuses on the Enterprise version, which is similar but not identical to the OSS version.\nArchitecture Conjur is distributed as a Docker image, making deployment and configuration fast and secure.\nThe main services included in the appliance image are:\nnginx: Provides access to the administrative GUI and the API set for interacting with secrets. PostgreSQL database: Two databases, one for configurations and secrets, and one for audit logs. Conjur appliance: The core product. syslog-ng: Used to collect audit and access logs. The smallest common configuration for Conjur Enterprise is a three-node cluster with auto-failover, as shown in the following diagram:\nThe cluster architecture follows an active-passive model, with high availability guaranteed by a load balancer placed in front of the cluster. This load balancer switches the node accessed by applications in case of a failure.\nWithin the cluster, one node acts as the “leader node,” handling all read/write operations and providing the API for applications to interact with secrets.\nThe secondary nodes are called “standbys” and can be either synchronous or asynchronous, depending on the PostgreSQL replication setup.\nThese nodes are inactive and do not provide API services.\nIf the leader node fails, after a configurable period, the standbys will elect a new leader using etcd and the Raft consensus algorithm.\nIf auto-failover is not configured, manual promotion is required.\nIt is also possible to configure a primary site with auto-failover and a secondary site with asynchronous standbys (without auto-failover), ready to be promoted manually.\nThe final component of the architecture is the “follower,” a read-only replica of the leader. Followers allow secrets to be read at scale and are horizontally scalable components typically configured behind a load balancer to handle all types of read requests, including authentication, permission checks, and secret fetches.\nFollowers are usually installed on a Kubernetes cluster to serve applications with low latency.\nThe architecture diagram with followers could be expanded as shown below:\nSystem Requirements Production environment:\n4 cores 8 GB RAM 50 GB hard drive Test environment:\n2 cores 4 GB RAM 20 GB hard drive Supported container runtimes:\nDocker 1.13 or later Mirantis Container Runtime (MRC) 19.x, 20.10 on RHEL 8.x Kubernetes and OpenShift (only for the follower) Podman 3.3 and 3.4 The host server should run an operating system supported by the container runtime (the most popular are RHEL Server, RHEL-based, or Ubuntu Server LTS). To read more detail or updated versions please refer to this page.\nIf the customer environment also includes a CyberArk Vault server that needs to be synchronized with Conjur, the following are the requirements for a CyberArk Vault Synchronizer server:\n4 cores 8 GB RAM Windows Server 2012 R2 or later ","permalink":"http://localhost:1313/posts/cyberark-conjur-architecture-system-requirements/","tags":["conjur","cyberark","secrets manager"],"title":"CyberArk Conjur: A Quick Overview of Architecture and System Requirements"},{"content":"Security is always a complex topic to address, as an error or omission in processes can lead to serious economic or reputational damage for a company.\nWhen we talk about “secrets,” consider the following examples:\nUsernames Database passwords SSL certificates and keys SSH keys Cloud credentials Simply reading through this list helps to explain why this topic needs to be considered and handled carefully.\nSome common bad practices or risks include:\nHardcoding secrets in code Data breaches Password leaks Secrets pushed to public repositories With practices like lateral movement, just one compromised secret can be enough to compromise an entire environment. To help prevent these risks, there are tools known as “enterprise secrets managers.” I’d like to start a series of posts on this blog about CyberArk Conjur.\nConjur allows you to avoid direct use of secrets by leveraging a set of REST APIs, making it a programmable tool that can be accessed via URL or open source utilities.\nSecurity is enforced through security policies without slowing down the developers involved.\nCorporate security can be further improved with the use of rotators, which programmatically change secret values.\nIf other CyberArk software like PAS Vault is already in use, Conjur can be integrated using the Synchroniser component,\nproviding the same level of security for cloud-native infrastructure.\nConjur is available in two versions: enterprise and open source, each with distinct features.\nIn upcoming posts, I will explain details about the architecture, secrets management, and product news related to CyberArk Conjur.\n","permalink":"http://localhost:1313/posts/why-you-need-kubernetes-secrets-manager/","tags":["conjur","introduction","secrets manager"],"title":"CyberArk Conjur - why you (probably) need an enterprise secrets manager"},{"content":"Hello there! How are you?\nI’m really good! As you may have seen on my social media, starting from the 16th of May, I’ve begun a new position as Senior DevSecOps at SIGHUP.\nI’m really excited about this new opportunity, and I’m writing this post because it will also have an effect on this blog’s focus.\nThe topics will shift from previous subjects to cloud-native infrastructure security, starting with tools like CyberArk Conjur. The previous content on this blog will remain here forever. I believe it could be helpful for some time, and I also want to honor my HCL Ambassador role.\nI’d also love to add that my current role as organizer of the LetsConnect user group will remain unchanged.\nI hope to see you all again at our next event!\n","permalink":"http://localhost:1313/posts/new-job-devsecops-teamleader/","tags":["cloudnative","newjob","devsecops","security"],"title":"I've started a new journey as DevSecOps Team Leader"},{"content":"","permalink":"http://localhost:1313/search/","tags":null,"title":"Search"},{"content":"Hello, I’m Matteo Bisi.\nI’m a DevSecOps Team Leader currently living in Galway, Ireland, but originally from Italy.\nWith a passion for both technology and teamwork, I lead my team in building and securing cloud-native infrastructures using both open source and enterprise tools.\nMy journey has taken me across different roles, giving me a unique perspective on how diverse teams collaborate and innovate.\nI’m particularly interested in automating security practices, managing secrets at scale, and empowering development teams to deliver secure software efficiently.\nOutside of work, I enjoy exploring the beautiful Irish countryside, planning my next family trip, and cooking some Italian recipes.\nThrough this blog, I hope to share insights, best practices, and lessons learned from my experiences leading DevSecOps teams.\nYou can find more information about my CV on my LinkedIn profile.\nMy preavious blogs about Collaboration solutions are available here:\nitalian blog english blog ","permalink":"http://localhost:1313/aboutme/","tags":["biography"],"title":"About Me - Matteo Bisi"},{"content":"During the past few weeks, I have described what a secrets manager is and provided an overview of the architecture and system requirements of CyberArk Conjur.\nA secrets manager can’t do its job if it can’t communicate with those who need to request secrets, and that’s where Conjur’s magic comes in!\nThe “authenticators” are responsible for the authentication process in Conjur and are specialized to do this in the most secure way, depending on the service.\nHere is the list of authenticators currently supported:\nAuthenticator Description authn Defines the Conjur default authenticator. Authentication for both users and hosts is based on an ID and API key. authn-oidc Leverages the identity layer provided by OIDC to allow applications to authenticate with Conjur and retrieve secrets needed for connecting to services such as a database. authn-iam Enables an AWS resource to use its AWS IAM role to authenticate with Conjur. authn-azure Enables an Azure resource to authenticate with Conjur authn-jwt Enables an application to authenticate to Conjur using a JWT from a JWT Provider. authn-gcp Enables a Google Cloud Platform resource to authenticate with Conjur authn-k8s Authenticates hosts that are Kubernetes resources, such as a Kubernetes namespace, deployment, stateful set, and others. Authentication is certificate-based using a mutual TLS connection. authn-ldap Authenticates users based on an LDAP directory. By default, after the initial setup, authn is the only authenticator enabled, and it is responsible for Conjur access using a username or API key (randomly generated between 51 and 56 characters).\nWhen integrations are needed, for example with a Kubernetes cluster, you need to activate and configure the authn-k8s authenticator. This authenticator can establish a secure mTLS connection compliant with the SPIFFE framework, as described in the following diagram (click here for more details).\nIf you need integrations with cloud identities that support JWT authentication, such as Google Apigee, you will enable the authn-jwt authenticator, which will perform the integrations as shown below:\nThese were just two examples among the many possible secure integrations enabled by the authenticators. The following is a more complete list:\nKubernetes (local or cloud) API gateway Jenkins Ansible Puppet Terraform Cloud services If the scenario described sounds interesting for your needs, Conjur could definitely be the right choice. Contact your sales representative at CyberArk or your preferred CyberArk business partner.\n","permalink":"http://localhost:1313/posts/cyberark-conjur-authenticators-integrations/","tags":["conjur","authenticators","spiffe","integrations"],"title":"CyberArk Conjur, authenticators and integrations"},{"content":"As I wrote in my last post, CyberArk Conjur is an enterprise secrets manager. , CyberArk Conjur is an enterprise secrets manager.\nIn this post, I’ll provide an architecture overview along with the main system requirements.\nConjur is currently available in two versions: Enterprise and open source (known as OSS).\nA “cloud” version will be available soon, offered as a SaaS solution.\nThis post focuses on the Enterprise version, which is similar but not identical to the OSS version.\nArchitecture Conjur is distributed as a Docker image, making deployment and configuration fast and secure.\nThe main services included in the appliance image are:\nnginx: Provides access to the administrative GUI and the API set for interacting with secrets. PostgreSQL database: Two databases, one for configurations and secrets, and one for audit logs. Conjur appliance: The core product. syslog-ng: Used to collect audit and access logs. The smallest common configuration for Conjur Enterprise is a three-node cluster with auto-failover, as shown in the following diagram:\nThe cluster architecture follows an active-passive model, with high availability guaranteed by a load balancer placed in front of the cluster. This load balancer switches the node accessed by applications in case of a failure.\nWithin the cluster, one node acts as the “leader node,” handling all read/write operations and providing the API for applications to interact with secrets.\nThe secondary nodes are called “standbys” and can be either synchronous or asynchronous, depending on the PostgreSQL replication setup.\nThese nodes are inactive and do not provide API services.\nIf the leader node fails, after a configurable period, the standbys will elect a new leader using etcd and the Raft consensus algorithm.\nIf auto-failover is not configured, manual promotion is required.\nIt is also possible to configure a primary site with auto-failover and a secondary site with asynchronous standbys (without auto-failover), ready to be promoted manually.\nThe final component of the architecture is the “follower,” a read-only replica of the leader. Followers allow secrets to be read at scale and are horizontally scalable components typically configured behind a load balancer to handle all types of read requests, including authentication, permission checks, and secret fetches.\nFollowers are usually installed on a Kubernetes cluster to serve applications with low latency.\nThe architecture diagram with followers could be expanded as shown below:\nSystem Requirements Production environment:\n4 cores 8 GB RAM 50 GB hard drive Test environment:\n2 cores 4 GB RAM 20 GB hard drive Supported container runtimes:\nDocker 1.13 or later Mirantis Container Runtime (MRC) 19.x, 20.10 on RHEL 8.x Kubernetes and OpenShift (only for the follower) Podman 3.3 and 3.4 The host server should run an operating system supported by the container runtime (the most popular are RHEL Server, RHEL-based, or Ubuntu Server LTS). To read more detail or updated versions please refer to this page.\nIf the customer environment also includes a CyberArk Vault server that needs to be synchronized with Conjur, the following are the requirements for a CyberArk Vault Synchronizer server:\n4 cores 8 GB RAM Windows Server 2012 R2 or later ","permalink":"http://localhost:1313/posts/cyberark-conjur-architecture-system-requirements/","tags":["conjur","cyberark","secrets manager"],"title":"CyberArk Conjur: A Quick Overview of Architecture and System Requirements"},{"content":"Security is always a complex topic to address, as an error or omission in processes can lead to serious economic or reputational damage for a company.\nWhen we talk about “secrets,” consider the following examples:\nUsernames Database passwords SSL certificates and keys SSH keys Cloud credentials Simply reading through this list helps to explain why this topic needs to be considered and handled carefully.\nSome common bad practices or risks include:\nHardcoding secrets in code Data breaches Password leaks Secrets pushed to public repositories With practices like lateral movement, just one compromised secret can be enough to compromise an entire environment. To help prevent these risks, there are tools known as “enterprise secrets managers.” I’d like to start a series of posts on this blog about CyberArk Conjur.\nConjur allows you to avoid direct use of secrets by leveraging a set of REST APIs, making it a programmable tool that can be accessed via URL or open source utilities.\nSecurity is enforced through security policies without slowing down the developers involved.\nCorporate security can be further improved with the use of rotators, which programmatically change secret values.\nIf other CyberArk software like PAS Vault is already in use, Conjur can be integrated using the Synchroniser component,\nproviding the same level of security for cloud-native infrastructure.\nConjur is available in two versions: enterprise and open source, each with distinct features.\nIn upcoming posts, I will explain details about the architecture, secrets management, and product news related to CyberArk Conjur.\n","permalink":"http://localhost:1313/posts/why-you-need-kubernetes-secrets-manager/","tags":["conjur","introduction","secrets manager"],"title":"CyberArk Conjur - why you (probably) need an enterprise secrets manager"},{"content":"Hello there! How are you?\nI’m really good! As you may have seen on my social media, starting from the 16th of May, I’ve begun a new position as Senior DevSecOps at SIGHUP.\nI’m really excited about this new opportunity, and I’m writing this post because it will also have an effect on this blog’s focus.\nThe topics will shift from previous subjects to cloud-native infrastructure security, starting with tools like CyberArk Conjur. The previous content on this blog will remain here forever. I believe it could be helpful for some time, and I also want to honor my HCL Ambassador role.\nI’d also love to add that my current role as organizer of the LetsConnect user group will remain unchanged.\nI hope to see you all again at our next event!\n","permalink":"http://localhost:1313/posts/new-job-devsecops-teamleader/","tags":["cloudnative","newjob","devsecops","security"],"title":"I've started a new journey as DevSecOps Team Leader"},{"content":"","permalink":"http://localhost:1313/search/","tags":null,"title":"Search"},{"content":"Hello, I’m Matteo Bisi.\nI’m a DevSecOps Team Leader currently living in Galway, Ireland, but originally from Italy.\nWith a passion for both technology and teamwork, I lead my team in building and securing cloud-native infrastructures using both open source and enterprise tools.\nMy journey has taken me across different roles, giving me a unique perspective on how diverse teams collaborate and innovate.\nI’m particularly interested in automating security practices, managing secrets at scale, and empowering development teams to deliver secure software efficiently.\nOutside of work, I enjoy exploring the beautiful Irish countryside, planning my next family trip, and cooking some Italian recipes.\nThrough this blog, I hope to share insights, best practices, and lessons learned from my experiences leading DevSecOps teams.\nYou can find more information about my CV on my LinkedIn profile.\nMy preavious blogs about Collaboration solutions are available here:\nitalian blog english blog ","permalink":"http://localhost:1313/aboutme/","tags":["biography"],"title":"About Me - Matteo Bisi"},{"content":"During the past few weeks, I have described what a secrets manager is and provided an overview of the architecture and system requirements of CyberArk Conjur.\nA secrets manager can’t do its job if it can’t communicate with those who need to request secrets, and that’s where Conjur’s magic comes in!\nThe “authenticators” are responsible for the authentication process in Conjur and are specialized to do this in the most secure way, depending on the service.\nHere is the list of authenticators currently supported:\nAuthenticator Description authn Defines the Conjur default authenticator. Authentication for both users and hosts is based on an ID and API key. authn-oidc Leverages the identity layer provided by OIDC to allow applications to authenticate with Conjur and retrieve secrets needed for connecting to services such as a database. authn-iam Enables an AWS resource to use its AWS IAM role to authenticate with Conjur. authn-azure Enables an Azure resource to authenticate with Conjur authn-jwt Enables an application to authenticate to Conjur using a JWT from a JWT Provider. authn-gcp Enables a Google Cloud Platform resource to authenticate with Conjur authn-k8s Authenticates hosts that are Kubernetes resources, such as a Kubernetes namespace, deployment, stateful set, and others. Authentication is certificate-based using a mutual TLS connection. authn-ldap Authenticates users based on an LDAP directory. By default, after the initial setup, authn is the only authenticator enabled, and it is responsible for Conjur access using a username or API key (randomly generated between 51 and 56 characters).\nWhen integrations are needed, for example with a Kubernetes cluster, you need to activate and configure the authn-k8s authenticator. This authenticator can establish a secure mTLS connection compliant with the SPIFFE framework, as described in the following diagram (click here for more details).\nIf you need integrations with cloud identities that support JWT authentication, such as Google Apigee, you will enable the authn-jwt authenticator, which will perform the integrations as shown below:\nThese were just two examples among the many possible secure integrations enabled by the authenticators. The following is a more complete list:\nKubernetes (local or cloud) API gateway Jenkins Ansible Puppet Terraform Cloud services If the scenario described sounds interesting for your needs, Conjur could definitely be the right choice. Contact your sales representative at CyberArk or your preferred CyberArk business partner.\n","permalink":"http://localhost:1313/posts/cyberark-conjur-authenticators-integrations/","tags":["conjur","authenticators","spiffe","integrations"],"title":"CyberArk Conjur, authenticators and integrations"},{"content":"As I wrote in my last post, CyberArk Conjur is an enterprise secrets manager. , CyberArk Conjur is an enterprise secrets manager.\nIn this post, I’ll provide an architecture overview along with the main system requirements.\nConjur is currently available in two versions: Enterprise and open source (known as OSS).\nA “cloud” version will be available soon, offered as a SaaS solution.\nThis post focuses on the Enterprise version, which is similar but not identical to the OSS version.\nArchitecture Conjur is distributed as a Docker image, making deployment and configuration fast and secure.\nThe main services included in the appliance image are:\nnginx: Provides access to the administrative GUI and the API set for interacting with secrets. PostgreSQL database: Two databases, one for configurations and secrets, and one for audit logs. Conjur appliance: The core product. syslog-ng: Used to collect audit and access logs. The smallest common configuration for Conjur Enterprise is a three-node cluster with auto-failover, as shown in the following diagram:\nThe cluster architecture follows an active-passive model, with high availability guaranteed by a load balancer placed in front of the cluster. This load balancer switches the node accessed by applications in case of a failure.\nWithin the cluster, one node acts as the “leader node,” handling all read/write operations and providing the API for applications to interact with secrets.\nThe secondary nodes are called “standbys” and can be either synchronous or asynchronous, depending on the PostgreSQL replication setup.\nThese nodes are inactive and do not provide API services.\nIf the leader node fails, after a configurable period, the standbys will elect a new leader using etcd and the Raft consensus algorithm.\nIf auto-failover is not configured, manual promotion is required.\nIt is also possible to configure a primary site with auto-failover and a secondary site with asynchronous standbys (without auto-failover), ready to be promoted manually.\nThe final component of the architecture is the “follower,” a read-only replica of the leader. Followers allow secrets to be read at scale and are horizontally scalable components typically configured behind a load balancer to handle all types of read requests, including authentication, permission checks, and secret fetches.\nFollowers are usually installed on a Kubernetes cluster to serve applications with low latency.\nThe architecture diagram with followers could be expanded as shown below:\nSystem Requirements Production environment:\n4 cores 8 GB RAM 50 GB hard drive Test environment:\n2 cores 4 GB RAM 20 GB hard drive Supported container runtimes:\nDocker 1.13 or later Mirantis Container Runtime (MRC) 19.x, 20.10 on RHEL 8.x Kubernetes and OpenShift (only for the follower) Podman 3.3 and 3.4 The host server should run an operating system supported by the container runtime (the most popular are RHEL Server, RHEL-based, or Ubuntu Server LTS). To read more detail or updated versions please refer to this page.\nIf the customer environment also includes a CyberArk Vault server that needs to be synchronized with Conjur, the following are the requirements for a CyberArk Vault Synchronizer server:\n4 cores 8 GB RAM Windows Server 2012 R2 or later ","permalink":"http://localhost:1313/posts/cyberark-conjur-architecture-system-requirements/","tags":["conjur","cyberark","secrets manager"],"title":"CyberArk Conjur: A Quick Overview of Architecture and System Requirements"},{"content":"Security is always a complex topic to address, as an error or omission in processes can lead to serious economic or reputational damage for a company.\nWhen we talk about “secrets,” consider the following examples:\nUsernames Database passwords SSL certificates and keys SSH keys Cloud credentials Simply reading through this list helps to explain why this topic needs to be considered and handled carefully.\nSome common bad practices or risks include:\nHardcoding secrets in code Data breaches Password leaks Secrets pushed to public repositories With practices like lateral movement, just one compromised secret can be enough to compromise an entire environment. To help prevent these risks, there are tools known as “enterprise secrets managers.” I’d like to start a series of posts on this blog about CyberArk Conjur.\nConjur allows you to avoid direct use of secrets by leveraging a set of REST APIs, making it a programmable tool that can be accessed via URL or open source utilities.\nSecurity is enforced through security policies without slowing down the developers involved.\nCorporate security can be further improved with the use of rotators, which programmatically change secret values.\nIf other CyberArk software like PAS Vault is already in use, Conjur can be integrated using the Synchroniser component,\nproviding the same level of security for cloud-native infrastructure.\nConjur is available in two versions: enterprise and open source, each with distinct features.\nIn upcoming posts, I will explain details about the architecture, secrets management, and product news related to CyberArk Conjur.\n","permalink":"http://localhost:1313/posts/why-you-need-kubernetes-secrets-manager/","tags":["conjur","introduction","secrets manager"],"title":"CyberArk Conjur - why you (probably) need an enterprise secrets manager"},{"content":"Hello there! How are you?\nI’m really good! As you may have seen on my social media, starting from the 16th of May, I’ve begun a new position as Senior DevSecOps at SIGHUP.\nI’m really excited about this new opportunity, and I’m writing this post because it will also have an effect on this blog’s focus.\nThe topics will shift from previous subjects to cloud-native infrastructure security, starting with tools like CyberArk Conjur. The previous content on this blog will remain here forever. I believe it could be helpful for some time, and I also want to honor my HCL Ambassador role.\nI’d also love to add that my current role as organizer of the LetsConnect user group will remain unchanged.\nI hope to see you all again at our next event!\n","permalink":"http://localhost:1313/posts/new-job-devsecops-teamleader/","tags":["cloudnative","newjob","devsecops","security"],"title":"I've started a new journey as DevSecOps Team Leader"},{"content":"","permalink":"http://localhost:1313/search/","tags":null,"title":"Search"},{"content":"Hello, I’m Matteo Bisi.\nI’m a DevSecOps Team Leader currently living in Galway, Ireland, but originally from Italy.\nWith a passion for both technology and teamwork, I lead my team in building and securing cloud-native infrastructures using both open source and enterprise tools.\nMy journey has taken me across different roles, giving me a unique perspective on how diverse teams collaborate and innovate.\nI’m particularly interested in automating security practices, managing secrets at scale, and empowering development teams to deliver secure software efficiently.\nOutside of work, I enjoy exploring the beautiful Irish countryside, planning my next family trip, and cooking some Italian recipes.\nThrough this blog, I hope to share insights, best practices, and lessons learned from my experiences leading DevSecOps teams.\nYou can find more information about my CV on my LinkedIn profile.\nMy preavious blogs about Collaboration solutions are available here:\nitalian blog english blog ","permalink":"http://localhost:1313/aboutme/","tags":["biography"],"title":"About Me - Matteo Bisi"},{"content":"During the past few weeks, I have described what a secrets manager is and provided an overview of the architecture and system requirements of CyberArk Conjur.\nA secrets manager can’t do its job if it can’t communicate with those who need to request secrets, and that’s where Conjur’s magic comes in!\nThe “authenticators” are responsible for the authentication process in Conjur and are specialized to do this in the most secure way, depending on the service.\nHere is the list of authenticators currently supported:\nAuthenticator Description authn Defines the Conjur default authenticator. Authentication for both users and hosts is based on an ID and API key. authn-oidc Leverages the identity layer provided by OIDC to allow applications to authenticate with Conjur and retrieve secrets needed for connecting to services such as a database. authn-iam Enables an AWS resource to use its AWS IAM role to authenticate with Conjur. authn-azure Enables an Azure resource to authenticate with Conjur authn-jwt Enables an application to authenticate to Conjur using a JWT from a JWT Provider. authn-gcp Enables a Google Cloud Platform resource to authenticate with Conjur authn-k8s Authenticates hosts that are Kubernetes resources, such as a Kubernetes namespace, deployment, stateful set, and others. Authentication is certificate-based using a mutual TLS connection. authn-ldap Authenticates users based on an LDAP directory. By default, after the initial setup, authn is the only authenticator enabled, and it is responsible for Conjur access using a username or API key (randomly generated between 51 and 56 characters).\nWhen integrations are needed, for example with a Kubernetes cluster, you need to activate and configure the authn-k8s authenticator. This authenticator can establish a secure mTLS connection compliant with the SPIFFE framework, as described in the following diagram (click here for more details).\nIf you need integrations with cloud identities that support JWT authentication, such as Google Apigee, you will enable the authn-jwt authenticator, which will perform the integrations as shown below:\nThese were just two examples among the many possible secure integrations enabled by the authenticators. The following is a more complete list:\nKubernetes (local or cloud) API gateway Jenkins Ansible Puppet Terraform Cloud services If the scenario described sounds interesting for your needs, Conjur could definitely be the right choice. Contact your sales representative at CyberArk or your preferred CyberArk business partner.\n","permalink":"http://localhost:1313/posts/cyberark-conjur-authenticators-integrations/","tags":["conjur","authenticators","spiffe","integrations"],"title":"CyberArk Conjur, authenticators and integrations"},{"content":"As I wrote in my last post, CyberArk Conjur is an enterprise secrets manager. , CyberArk Conjur is an enterprise secrets manager.\nIn this post, I’ll provide an architecture overview along with the main system requirements.\nConjur is currently available in two versions: Enterprise and open source (known as OSS).\nA “cloud” version will be available soon, offered as a SaaS solution.\nThis post focuses on the Enterprise version, which is similar but not identical to the OSS version.\nArchitecture Conjur is distributed as a Docker image, making deployment and configuration fast and secure.\nThe main services included in the appliance image are:\nnginx: Provides access to the administrative GUI and the API set for interacting with secrets. PostgreSQL database: Two databases, one for configurations and secrets, and one for audit logs. Conjur appliance: The core product. syslog-ng: Used to collect audit and access logs. The smallest common configuration for Conjur Enterprise is a three-node cluster with auto-failover, as shown in the following diagram:\nThe cluster architecture follows an active-passive model, with high availability guaranteed by a load balancer placed in front of the cluster. This load balancer switches the node accessed by applications in case of a failure.\nWithin the cluster, one node acts as the “leader node,” handling all read/write operations and providing the API for applications to interact with secrets.\nThe secondary nodes are called “standbys” and can be either synchronous or asynchronous, depending on the PostgreSQL replication setup.\nThese nodes are inactive and do not provide API services.\nIf the leader node fails, after a configurable period, the standbys will elect a new leader using etcd and the Raft consensus algorithm.\nIf auto-failover is not configured, manual promotion is required.\nIt is also possible to configure a primary site with auto-failover and a secondary site with asynchronous standbys (without auto-failover), ready to be promoted manually.\nThe final component of the architecture is the “follower,” a read-only replica of the leader. Followers allow secrets to be read at scale and are horizontally scalable components typically configured behind a load balancer to handle all types of read requests, including authentication, permission checks, and secret fetches.\nFollowers are usually installed on a Kubernetes cluster to serve applications with low latency.\nThe architecture diagram with followers could be expanded as shown below:\nSystem Requirements Production environment:\n4 cores 8 GB RAM 50 GB hard drive Test environment:\n2 cores 4 GB RAM 20 GB hard drive Supported container runtimes:\nDocker 1.13 or later Mirantis Container Runtime (MRC) 19.x, 20.10 on RHEL 8.x Kubernetes and OpenShift (only for the follower) Podman 3.3 and 3.4 The host server should run an operating system supported by the container runtime (the most popular are RHEL Server, RHEL-based, or Ubuntu Server LTS). To read more detail or updated versions please refer to this page.\nIf the customer environment also includes a CyberArk Vault server that needs to be synchronized with Conjur, the following are the requirements for a CyberArk Vault Synchronizer server:\n4 cores 8 GB RAM Windows Server 2012 R2 or later ","permalink":"http://localhost:1313/posts/cyberark-conjur-architecture-system-requirements/","tags":["conjur","cyberark","secrets manager"],"title":"CyberArk Conjur: A Quick Overview of Architecture and System Requirements"},{"content":"Security is always a complex topic to address, as an error or omission in processes can lead to serious economic or reputational damage for a company.\nWhen we talk about “secrets,” consider the following examples:\nUsernames Database passwords SSL certificates and keys SSH keys Cloud credentials Simply reading through this list helps to explain why this topic needs to be considered and handled carefully.\nSome common bad practices or risks include:\nHardcoding secrets in code Data breaches Password leaks Secrets pushed to public repositories With practices like lateral movement, just one compromised secret can be enough to compromise an entire environment. To help prevent these risks, there are tools known as “enterprise secrets managers.” I’d like to start a series of posts on this blog about CyberArk Conjur.\nConjur allows you to avoid direct use of secrets by leveraging a set of REST APIs, making it a programmable tool that can be accessed via URL or open source utilities.\nSecurity is enforced through security policies without slowing down the developers involved.\nCorporate security can be further improved with the use of rotators, which programmatically change secret values.\nIf other CyberArk software like PAS Vault is already in use, Conjur can be integrated using the Synchroniser component,\nproviding the same level of security for cloud-native infrastructure.\nConjur is available in two versions: enterprise and open source, each with distinct features.\nIn upcoming posts, I will explain details about the architecture, secrets management, and product news related to CyberArk Conjur.\n","permalink":"http://localhost:1313/posts/why-you-need-kubernetes-secrets-manager/","tags":["conjur","introduction","secrets manager"],"title":"CyberArk Conjur - why you (probably) need an enterprise secrets manager"},{"content":"Hello there! How are you?\nI’m really good! As you may have seen on my social media, starting from the 16th of May, I’ve begun a new position as Senior DevSecOps at SIGHUP.\nI’m really excited about this new opportunity, and I’m writing this post because it will also have an effect on this blog’s focus.\nThe topics will shift from previous subjects to cloud-native infrastructure security, starting with tools like CyberArk Conjur. The previous content on this blog will remain here forever. I believe it could be helpful for some time, and I also want to honor my HCL Ambassador role.\nI’d also love to add that my current role as organizer of the LetsConnect user group will remain unchanged.\nI hope to see you all again at our next event!\n","permalink":"http://localhost:1313/posts/new-job-devsecops-teamleader/","tags":["cloudnative","newjob","devsecops","security"],"title":"I've started a new journey as DevSecOps Team Leader"},{"content":"","permalink":"http://localhost:1313/search/","tags":null,"title":"Search"},{"content":"Hello, I’m Matteo Bisi.\nI’m a DevSecOps Team Leader currently living in Galway, Ireland, but originally from Italy.\nWith a passion for both technology and teamwork, I lead my team in building and securing cloud-native infrastructures using both open source and enterprise tools.\nMy journey has taken me across different roles, giving me a unique perspective on how diverse teams collaborate and innovate.\nI’m particularly interested in automating security practices, managing secrets at scale, and empowering development teams to deliver secure software efficiently.\nOutside of work, I enjoy exploring the beautiful Irish countryside, planning my next family trip, and cooking some Italian recipes.\nThrough this blog, I hope to share insights, best practices, and lessons learned from my experiences leading DevSecOps teams.\nYou can find more information about my CV on my LinkedIn profile.\nMy preavious blogs about Collaboration solutions are available here:\nitalian blog english blog ","permalink":"http://localhost:1313/aboutme/","tags":["biography"],"title":"About Me - Matteo Bisi"},{"content":"During the past few weeks, I have described what a secrets manager is and provided an overview of the architecture and system requirements of CyberArk Conjur.\nA secrets manager can’t do its job if it can’t communicate with those who need to request secrets, and that’s where Conjur’s magic comes in!\nThe “authenticators” are responsible for the authentication process in Conjur and are specialized to do this in the most secure way, depending on the service.\nHere is the list of authenticators currently supported:\nAuthenticator Description authn Defines the Conjur default authenticator. Authentication for both users and hosts is based on an ID and API key. authn-oidc Leverages the identity layer provided by OIDC to allow applications to authenticate with Conjur and retrieve secrets needed for connecting to services such as a database. authn-iam Enables an AWS resource to use its AWS IAM role to authenticate with Conjur. authn-azure Enables an Azure resource to authenticate with Conjur authn-jwt Enables an application to authenticate to Conjur using a JWT from a JWT Provider. authn-gcp Enables a Google Cloud Platform resource to authenticate with Conjur authn-k8s Authenticates hosts that are Kubernetes resources, such as a Kubernetes namespace, deployment, stateful set, and others. Authentication is certificate-based using a mutual TLS connection. authn-ldap Authenticates users based on an LDAP directory. By default, after the initial setup, authn is the only authenticator enabled, and it is responsible for Conjur access using a username or API key (randomly generated between 51 and 56 characters).\nWhen integrations are needed, for example with a Kubernetes cluster, you need to activate and configure the authn-k8s authenticator. This authenticator can establish a secure mTLS connection compliant with the SPIFFE framework, as described in the following diagram (click here for more details).\nIf you need integrations with cloud identities that support JWT authentication, such as Google Apigee, you will enable the authn-jwt authenticator, which will perform the integrations as shown below:\nThese were just two examples among the many possible secure integrations enabled by the authenticators. The following is a more complete list:\nKubernetes (local or cloud) API gateway Jenkins Ansible Puppet Terraform Cloud services If the scenario described sounds interesting for your needs, Conjur could definitely be the right choice. Contact your sales representative at CyberArk or your preferred CyberArk business partner.\n","permalink":"http://localhost:1313/posts/cyberark-conjur-authenticators-integrations/","tags":["conjur","authenticators","spiffe","integrations"],"title":"CyberArk Conjur, authenticators and integrations"},{"content":"As I wrote in my last post, CyberArk Conjur is an enterprise secrets manager. , CyberArk Conjur is an enterprise secrets manager.\nIn this post, I’ll provide an architecture overview along with the main system requirements.\nConjur is currently available in two versions: Enterprise and open source (known as OSS).\nA “cloud” version will be available soon, offered as a SaaS solution.\nThis post focuses on the Enterprise version, which is similar but not identical to the OSS version.\nArchitecture Conjur is distributed as a Docker image, making deployment and configuration fast and secure.\nThe main services included in the appliance image are:\nnginx: Provides access to the administrative GUI and the API set for interacting with secrets. PostgreSQL database: Two databases, one for configurations and secrets, and one for audit logs. Conjur appliance: The core product. syslog-ng: Used to collect audit and access logs. The smallest common configuration for Conjur Enterprise is a three-node cluster with auto-failover, as shown in the following diagram:\nThe cluster architecture follows an active-passive model, with high availability guaranteed by a load balancer placed in front of the cluster. This load balancer switches the node accessed by applications in case of a failure.\nWithin the cluster, one node acts as the “leader node,” handling all read/write operations and providing the API for applications to interact with secrets.\nThe secondary nodes are called “standbys” and can be either synchronous or asynchronous, depending on the PostgreSQL replication setup.\nThese nodes are inactive and do not provide API services.\nIf the leader node fails, after a configurable period, the standbys will elect a new leader using etcd and the Raft consensus algorithm.\nIf auto-failover is not configured, manual promotion is required.\nIt is also possible to configure a primary site with auto-failover and a secondary site with asynchronous standbys (without auto-failover), ready to be promoted manually.\nThe final component of the architecture is the “follower,” a read-only replica of the leader. Followers allow secrets to be read at scale and are horizontally scalable components typically configured behind a load balancer to handle all types of read requests, including authentication, permission checks, and secret fetches.\nFollowers are usually installed on a Kubernetes cluster to serve applications with low latency.\nThe architecture diagram with followers could be expanded as shown below:\nSystem Requirements Production environment:\n4 cores 8 GB RAM 50 GB hard drive Test environment:\n2 cores 4 GB RAM 20 GB hard drive Supported container runtimes:\nDocker 1.13 or later Mirantis Container Runtime (MRC) 19.x, 20.10 on RHEL 8.x Kubernetes and OpenShift (only for the follower) Podman 3.3 and 3.4 The host server should run an operating system supported by the container runtime (the most popular are RHEL Server, RHEL-based, or Ubuntu Server LTS). To read more detail or updated versions please refer to this page.\nIf the customer environment also includes a CyberArk Vault server that needs to be synchronized with Conjur, the following are the requirements for a CyberArk Vault Synchronizer server:\n4 cores 8 GB RAM Windows Server 2012 R2 or later ","permalink":"http://localhost:1313/posts/cyberark-conjur-architecture-system-requirements/","tags":["conjur","cyberark","secrets manager"],"title":"CyberArk Conjur: A Quick Overview of Architecture and System Requirements"},{"content":"Security is always a complex topic to address, as an error or omission in processes can lead to serious economic or reputational damage for a company.\nWhen we talk about “secrets,” consider the following examples:\nUsernames Database passwords SSL certificates and keys SSH keys Cloud credentials Simply reading through this list helps to explain why this topic needs to be considered and handled carefully.\nSome common bad practices or risks include:\nHardcoding secrets in code Data breaches Password leaks Secrets pushed to public repositories With practices like lateral movement, just one compromised secret can be enough to compromise an entire environment. To help prevent these risks, there are tools known as “enterprise secrets managers.” I’d like to start a series of posts on this blog about CyberArk Conjur.\nConjur allows you to avoid direct use of secrets by leveraging a set of REST APIs, making it a programmable tool that can be accessed via URL or open source utilities.\nSecurity is enforced through security policies without slowing down the developers involved.\nCorporate security can be further improved with the use of rotators, which programmatically change secret values.\nIf other CyberArk software like PAS Vault is already in use, Conjur can be integrated using the Synchroniser component,\nproviding the same level of security for cloud-native infrastructure.\nConjur is available in two versions: enterprise and open source, each with distinct features.\nIn upcoming posts, I will explain details about the architecture, secrets management, and product news related to CyberArk Conjur.\n","permalink":"http://localhost:1313/posts/why-you-need-kubernetes-secrets-manager/","tags":["conjur","introduction","secrets manager"],"title":"CyberArk Conjur - why you (probably) need an enterprise secrets manager"},{"content":"Hello there! How are you?\nI’m really good! As you may have seen on my social media, starting from the 16th of May, I’ve begun a new position as Senior DevSecOps at SIGHUP.\nI’m really excited about this new opportunity, and I’m writing this post because it will also have an effect on this blog’s focus.\nThe topics will shift from previous subjects to cloud-native infrastructure security, starting with tools like CyberArk Conjur. The previous content on this blog will remain here forever. I believe it could be helpful for some time, and I also want to honor my HCL Ambassador role.\nI’d also love to add that my current role as organizer of the LetsConnect user group will remain unchanged.\nI hope to see you all again at our next event!\n","permalink":"http://localhost:1313/posts/new-job-devsecops-teamleader/","tags":["cloudnative","newjob","devsecops","security"],"title":"I've started a new journey as DevSecOps Team Leader"},{"content":"","permalink":"http://localhost:1313/search/","tags":null,"title":"Search"},{"content":"Hello, I’m Matteo Bisi.\nI’m a DevSecOps Team Leader currently living in Galway, Ireland, but originally from Italy.\nWith a passion for both technology and teamwork, I lead my team in building and securing cloud-native infrastructures using both open source and enterprise tools.\nMy journey has taken me across different roles, giving me a unique perspective on how diverse teams collaborate and innovate.\nI’m particularly interested in automating security practices, managing secrets at scale, and empowering development teams to deliver secure software efficiently.\nOutside of work, I enjoy exploring the beautiful Irish countryside, planning my next family trip, and cooking some Italian recipes.\nThrough this blog, I hope to share insights, best practices, and lessons learned from my experiences leading DevSecOps teams.\nYou can find more information about my CV on my LinkedIn profile.\nMy preavious blogs about Collaboration solutions are available here:\nitalian blog english blog ","permalink":"http://localhost:1313/aboutme/","tags":["biography"],"title":"About Me - Matteo Bisi"},{"content":"During the past few weeks, I have described what a secrets manager is and provided an overview of the architecture and system requirements of CyberArk Conjur.\nA secrets manager can’t do its job if it can’t communicate with those who need to request secrets, and that’s where Conjur’s magic comes in!\nThe “authenticators” are responsible for the authentication process in Conjur and are specialized to do this in the most secure way, depending on the service.\nHere is the list of authenticators currently supported:\nAuthenticator Description authn Defines the Conjur default authenticator. Authentication for both users and hosts is based on an ID and API key. authn-oidc Leverages the identity layer provided by OIDC to allow applications to authenticate with Conjur and retrieve secrets needed for connecting to services such as a database. authn-iam Enables an AWS resource to use its AWS IAM role to authenticate with Conjur. authn-azure Enables an Azure resource to authenticate with Conjur authn-jwt Enables an application to authenticate to Conjur using a JWT from a JWT Provider. authn-gcp Enables a Google Cloud Platform resource to authenticate with Conjur authn-k8s Authenticates hosts that are Kubernetes resources, such as a Kubernetes namespace, deployment, stateful set, and others. Authentication is certificate-based using a mutual TLS connection. authn-ldap Authenticates users based on an LDAP directory. By default, after the initial setup, authn is the only authenticator enabled, and it is responsible for Conjur access using a username or API key (randomly generated between 51 and 56 characters).\nWhen integrations are needed, for example with a Kubernetes cluster, you need to activate and configure the authn-k8s authenticator. This authenticator can establish a secure mTLS connection compliant with the SPIFFE framework, as described in the following diagram (click here for more details).\nIf you need integrations with cloud identities that support JWT authentication, such as Google Apigee, you will enable the authn-jwt authenticator, which will perform the integrations as shown below:\nThese were just two examples among the many possible secure integrations enabled by the authenticators. The following is a more complete list:\nKubernetes (local or cloud) API gateway Jenkins Ansible Puppet Terraform Cloud services If the scenario described sounds interesting for your needs, Conjur could definitely be the right choice. Contact your sales representative at CyberArk or your preferred CyberArk business partner.\n","permalink":"http://localhost:1313/posts/cyberark-conjur-authenticators-integrations/","tags":["conjur","authenticators","spiffe","integrations"],"title":"CyberArk Conjur, authenticators and integrations"},{"content":"As I wrote in my last post, CyberArk Conjur is an enterprise secrets manager. , CyberArk Conjur is an enterprise secrets manager.\nIn this post, I’ll provide an architecture overview along with the main system requirements.\nConjur is currently available in two versions: Enterprise and open source (known as OSS).\nA “cloud” version will be available soon, offered as a SaaS solution.\nThis post focuses on the Enterprise version, which is similar but not identical to the OSS version.\nArchitecture Conjur is distributed as a Docker image, making deployment and configuration fast and secure.\nThe main services included in the appliance image are:\nnginx: Provides access to the administrative GUI and the API set for interacting with secrets. PostgreSQL database: Two databases, one for configurations and secrets, and one for audit logs. Conjur appliance: The core product. syslog-ng: Used to collect audit and access logs. The smallest common configuration for Conjur Enterprise is a three-node cluster with auto-failover, as shown in the following diagram:\nThe cluster architecture follows an active-passive model, with high availability guaranteed by a load balancer placed in front of the cluster. This load balancer switches the node accessed by applications in case of a failure.\nWithin the cluster, one node acts as the “leader node,” handling all read/write operations and providing the API for applications to interact with secrets.\nThe secondary nodes are called “standbys” and can be either synchronous or asynchronous, depending on the PostgreSQL replication setup.\nThese nodes are inactive and do not provide API services.\nIf the leader node fails, after a configurable period, the standbys will elect a new leader using etcd and the Raft consensus algorithm.\nIf auto-failover is not configured, manual promotion is required.\nIt is also possible to configure a primary site with auto-failover and a secondary site with asynchronous standbys (without auto-failover), ready to be promoted manually.\nThe final component of the architecture is the “follower,” a read-only replica of the leader. Followers allow secrets to be read at scale and are horizontally scalable components typically configured behind a load balancer to handle all types of read requests, including authentication, permission checks, and secret fetches.\nFollowers are usually installed on a Kubernetes cluster to serve applications with low latency.\nThe architecture diagram with followers could be expanded as shown below:\nSystem Requirements Production environment:\n4 cores 8 GB RAM 50 GB hard drive Test environment:\n2 cores 4 GB RAM 20 GB hard drive Supported container runtimes:\nDocker 1.13 or later Mirantis Container Runtime (MRC) 19.x, 20.10 on RHEL 8.x Kubernetes and OpenShift (only for the follower) Podman 3.3 and 3.4 The host server should run an operating system supported by the container runtime (the most popular are RHEL Server, RHEL-based, or Ubuntu Server LTS). To read more detail or updated versions please refer to this page.\nIf the customer environment also includes a CyberArk Vault server that needs to be synchronized with Conjur, the following are the requirements for a CyberArk Vault Synchronizer server:\n4 cores 8 GB RAM Windows Server 2012 R2 or later ","permalink":"http://localhost:1313/posts/cyberark-conjur-architecture-system-requirements/","tags":["conjur","cyberark","secrets manager"],"title":"CyberArk Conjur: A Quick Overview of Architecture and System Requirements"},{"content":"Security is always a complex topic to address, as an error or omission in processes can lead to serious economic or reputational damage for a company.\nWhen we talk about “secrets,” consider the following examples:\nUsernames Database passwords SSL certificates and keys SSH keys Cloud credentials Simply reading through this list helps to explain why this topic needs to be considered and handled carefully.\nSome common bad practices or risks include:\nHardcoding secrets in code Data breaches Password leaks Secrets pushed to public repositories With practices like lateral movement, just one compromised secret can be enough to compromise an entire environment. To help prevent these risks, there are tools known as “enterprise secrets managers.” I’d like to start a series of posts on this blog about CyberArk Conjur.\nConjur allows you to avoid direct use of secrets by leveraging a set of REST APIs, making it a programmable tool that can be accessed via URL or open source utilities.\nSecurity is enforced through security policies without slowing down the developers involved.\nCorporate security can be further improved with the use of rotators, which programmatically change secret values.\nIf other CyberArk software like PAS Vault is already in use, Conjur can be integrated using the Synchroniser component,\nproviding the same level of security for cloud-native infrastructure.\nConjur is available in two versions: enterprise and open source, each with distinct features.\nIn upcoming posts, I will explain details about the architecture, secrets management, and product news related to CyberArk Conjur.\n","permalink":"http://localhost:1313/posts/why-you-need-kubernetes-secrets-manager/","tags":["conjur","introduction","secrets manager"],"title":"CyberArk Conjur - why you (probably) need an enterprise secrets manager"},{"content":"Hello there! How are you?\nI’m really good! As you may have seen on my social media, starting from the 16th of May, I’ve begun a new position as Senior DevSecOps at SIGHUP.\nI’m really excited about this new opportunity, and I’m writing this post because it will also have an effect on this blog’s focus.\nThe topics will shift from previous subjects to cloud-native infrastructure security, starting with tools like CyberArk Conjur. The previous content on this blog will remain here forever. I believe it could be helpful for some time, and I also want to honor my HCL Ambassador role.\nI’d also love to add that my current role as organizer of the LetsConnect user group will remain unchanged.\nI hope to see you all again at our next event!\n","permalink":"http://localhost:1313/posts/new-job-devsecops-teamleader/","tags":["cloudnative","newjob","devsecops","security"],"title":"I've started a new journey as DevSecOps Team Leader"},{"content":"","permalink":"http://localhost:1313/search/","tags":null,"title":"Search"}]